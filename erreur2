createAMFeesUI <- function(id, reactiveReportObject, user = "", tokenUI = "") {
  ns <- NS(id)

  observe({
    req(reactiveReportObject$app)
    appSelected <- reactiveReportObject$app
    if (!tolower(gsub_underscore_dash(" ", "_", appSelected)) %in% c("am_fees")) {
      return()
    }

    showPageSpinner()
    tryCatch({
      # Cleanup previous content
      removeUI(selector = paste0("#", id, "ContentAnalysis"), immediate = TRUE)

      data_list <- reactiveReportObject$reportData
      if (is.null(data_list)) {
        hidePageSpinner()
        return()
      }
      if (!is.list(data_list)) {
        data_list <- list(data_list)
        names(data_list) <- c("Report")
      }

      # Build tabs
      tabs <- Map(function(i) list(id = paste0(id, "-", i, "_", tokenUI), name = names(data_list)[i]), seq_len(length(data_list)))

      ui_root <- tags$div(
        id = paste0(id, "ContentAnalysis"),
        class = "row",
        tags$div(class = "col-12 mb-2",
          downloadButton(ns(paste0("download_all_data_excel_", tokenUI)), "ðŸ“¦ Download all in Excel", class = "btn btn-primary my-2")
        ),
        tags$div(class = "col-12", Generate_dashboard_tabs_table(tabs))
      )

      insertUI(selector = paste0("#", id, "Content"), ui = ui_root, immediate = TRUE)

      # Populate each tab content
      for (i in seq_along(data_list)) {
        local({
          idx <- i
          df <- data_list[[idx]]
          table_name <- names(data_list)[idx]

          tab_id <- paste0(id, "-", idx, "_", tokenUI)

          # Add per-tab controls (download button) above the DT
          insertUI(
            selector = paste0("#nav-", tab_id),
            where = "afterBegin",
            ui = tags$div(
              class = "my-3",
              fluidRow(
                column(12, class = "d-flex justify-content-between align-items-center mb-2",
                  downloadButton(outputId = paste0("download_", tab_id, "_", tokenUI), label = "ðŸ“¥ Download CSV", class = "btn btn-sm btn-success")
                )
              )
            )
          )

          # Table (target id inserted by Generate_dashboard_tabs_table)
          output[[paste0("td_dashboard_", tab_id)]] <- renderDT({
            num_cols <- names(df)[sapply(df, is.numeric)]
            df_clean <- df
            show_total <- grepl("calcul_report|kpi_axa_im_report", gsub_underscore_dash(" ", "_", tolower(table_name)))
            if (show_total && length(num_cols) > 0) {
              total_row <- df_clean[, lapply(.SD, function(x) if (is.numeric(x)) sum(x, na.rm = TRUE) else NA), .SDcols = num_cols]
              total_row[, setdiff(names(df_clean), num_cols) := lapply(setdiff(names(df_clean), num_cols), function(x) "Total")]
              df_clean <- rbind(df_clean, total_row, fill = TRUE)
            }
            dt <- datatable(
              df_clean,
              rownames = FALSE,
              options = list(paging = FALSE, dom = 'tip', autoWidth = TRUE, ordering = TRUE),
              filter = "top"
            )
            for (col in num_cols) {
              dt <- DT::formatCurrency(dt, columns = col, currency = "", digits = 0, interval = 3, mark = " ")
            }
            if (show_total) {
              dt <- DT::formatStyle(dt, columns = 0, target = "row", rows = nrow(df_clean), fontWeight = "bold", backgroundColor = "#f9f9f9")
            }
            dt
          })

          # Downloads
          output[[paste0("download_", tab_id, "_", tokenUI)]] <- downloadHandler(
            filename = function() paste0(gsub("[\\/:*?\"<>|]", "_", table_name), ".csv"),
            content = function(file) {
              fwrite(df, file, row.names = FALSE, sep = user_separator(), quote = TRUE)
            }
          )
        })
      }

      # Download all to Excel
      output[[ns(paste0("download_all_data_excel_", tokenUI))]] <- downloadHandler(
        filename = function() paste0("AMFees_Report_", Sys.Date(), ".xlsx"),
        content = function(file) {
          openxlsx::write.xlsx(data_list, file)
        }
      )

      hidePageSpinner()
      runjs("$('a[href=\"#historyAnalysis\"]').click();")
    }, error = function(e) {
      print(e)
      hidePageSpinner()
      runjs("toastr.error('Error.. please retry again','',toastr.options.timeOut='500');")
    })
  })
}








parseUploadedFiles <- function(lfiles, path_admin_param_data_dictionary, specific_read = NULL) {
  if (is.null(lfiles)) return(NULL) # Return NULL if no files are uploaded

  # Create a data table to store file information (name, path, extension)
  file_info <- data.table(
      name = lfiles$name,
      datapath = lfiles$datapath,
      file_ext = tolower(tools::file_ext(lfiles$name)),
      stringsAsFactors = FALSE
  )


if(!is.null(specific_read)){
  
}




  # Process ZIP files in parallel
  processed_files <- mclapply(1:nrow(lfiles), separate_zip_files, file_info = file_info, mc.cores = detectCores() - 1)
  # Flatten the list of processed files and convert it to a data.table
  df <- rbindlist(processed_files)
  df$file_name <- df$name
  df$size <- file_size_formated(df$size)

  # Extract input types and compatible versions from the file paths
  file_and_versions <- lapply(df$datapath, Foundation_input_from_path, path_admin_param_data_dictionary = path_admin_param_data_dictionary, app = isolate({user_repository()}))
  df$input_type <- unlist(lapply(file_and_versions, `[[`, "input_type"))
  df$compatible_versions <- unlist(lapply(file_and_versions, `[[`, "compatible_versions"))
  df$tmp_path <- df$datapath
  df$originType <- "csv"
  df <- df[,c("file_name", "size", "input_type", "compatible_versions", "tmp_path", "originType")]

  # Handle Excel files (xlsx, xls) and convert them to CSV
  xlsx_paths <- df$tmp_path[tools::file_ext(df$tmp_path) %in% c("xlsx", "xls")]
  if (length(xlsx_paths) > 0) {
      clean_tmp_files(path_tmpUploads) # Clean temporary files before processing
      for (path_xl in xlsx_paths) {
        if (length(excel_sheets(path_xl)) >= 1) { # If there are sheets in the Excel file
            name_xl <- tools::file_path_sans_ext(df$file_name[df$tmp_path == path_xl])
            df_csvs <- Sheets_to_csv(path_xl, name_xl, path_tmpUploads, path_admin_param_data_dictionary, quoteParam = TRUE) # Convert sheets to CSV
            df_csvs$originType <- "xlsx"
            df <- df[df$tmp_path != path_xl, ] # Remove the original Excel file from the data.table
            df <- rbind(df, df_csvs) # Add the converted CSV files to the data.table
        }
      }
  }

  # If no files are left after processing, show an error message
  if (nrow(df) == 0) {
    return(NULL)
  }
  df  # Return the processed data.table  
}




  # Process ZIP files in parallel
  processed_files <- mclapply(1:nrow(lfiles), separate_zip_files, file_info = file_info, mc.cores = detectCores() - 1)
  # Flatten the list of processed files and convert it to a data.table
  df <- rbindlist(processed_files)
  df$file_name <- df$name
  df$size <- file_size_formated(df$size)



specific_read <- function(df, appName){
  if(gsub_underscore_dash(" ", "_", tolower(appName)) == "var_ifrs_17"){
    
    df <- df # traitement
  }
  return(df)
}






specific_read <- function(df, appName){
  if(gsub_underscore_dash(" ", "_", tolower(appName)) == "var_ifrs_17"){
    
    # CrÃ©er une copie du df original pour les ajouts
    df_copies <- data.table()
    
    # Traiter le fichier Actuarial_All_Goc_Goc_Curr
    if(any(grepl("Actuarial_All_Goc_Goc_Curr", df$file_name, ignore.case = TRUE))) {
      # Trouver l'index du fichier Actuarial_All_Goc_Goc_Curr
      idx_actuarial <- which(grepl("Actuarial_All_Goc_Goc_Curr", df$file_name, ignore.case = TRUE))[1]
      
      # CrÃ©er une copie avec le nouveau nom
      copy_actuarial_rep <- df[idx_actuarial]
      copy_actuarial_rep$file_name <- gsub("Actuarial_All_Goc_Goc_Curr", "Actuarial_All_Goc_Rep_Curr", 
                                          copy_actuarial_rep$file_name, ignore.case = TRUE)
      
      # Lire le fichier CSV original pour modifier les colonnes
      original_data <- fread(df$tmp_path[idx_actuarial])
      
      # Ajouter "_2" Ã  toutes les colonnes
      new_colnames <- paste0(colnames(original_data), "_2")
      colnames(original_data) <- new_colnames
      
      # CrÃ©er un nouveau fichier temporaire avec les colonnes modifiÃ©es
      new_tmp_path <- file.path(dirname(copy_actuarial_rep$tmp_path), 
                               paste0("Actuarial_All_Goc_Rep_Curr_", basename(copy_actuarial_rep$tmp_path)))
      fwrite(original_data, new_tmp_path)
      copy_actuarial_rep$tmp_path <- new_tmp_path
      
      # Ajouter Ã  df_copies
      df_copies <- rbind(df_copies, copy_actuarial_rep)
    }
    
    # Traiter le fichier IFRS17_All_Goc_Goc_Curr
    if(any(grepl("IFRS17_All_Goc_Goc_Curr", df$file_name, ignore.case = TRUE))) {
      # Trouver l'index du fichier IFRS17_All_Goc_Goc_Curr
      idx_ifrs17 <- which(grepl("IFRS17_All_Goc_Goc_Curr", df$file_name, ignore.case = TRUE))[1]
      
      # CrÃ©er une copie avec le nouveau nom
      copy_ifrs17_rep <- df[idx_ifrs17]
      copy_ifrs17_rep$file_name <- gsub("IFRS17_All_Goc_Goc_Curr", "IFRS17_All_Goc_Rep_Curr", 
                                       copy_ifrs17_rep$file_name, ignore.case = TRUE)
      
      # Lire le fichier CSV original pour modifier les colonnes
      original_data <- fread(df$tmp_path[idx_ifrs17])
      
      # Ajouter "_2" Ã  toutes les colonnes
      new_colnames <- paste0(colnames(original_data), "_2")
      colnames(original_data) <- new_colnames
      
      # CrÃ©er un nouveau fichier temporaire avec les colonnes modifiÃ©es
      new_tmp_path <- file.path(dirname(copy_ifrs17_rep$tmp_path), 
                               paste0("IFRS17_All_Goc_Rep_Curr_", basename(copy_ifrs17_rep$tmp_path)))
      fwrite(original_data, new_tmp_path)
      copy_ifrs17_rep$tmp_path <- new_tmp_path
      
      # Ajouter Ã  df_copies
      df_copies <- rbind(df_copies, copy_ifrs17_rep)
    }
    
    # Combiner le df original avec les copies
    if(nrow(df_copies) > 0) {
      df <- rbind(df, df_copies)
    }
  }
  
  return(df)
}



if(!is.null(specific_read)){
  df <- specific_read(df, isolate({user_repository()}))
}
