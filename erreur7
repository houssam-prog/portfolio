#----------------------------------------------------------------------------------#
#------------------------- SOLUTION GÃ‰NÃ‰RIQUE COMPLÃˆTEMENT FACTORISÃ‰E ------------#
#----------------------------------------------------------------------------------#

#----------------------------------------------------------------------------------#
#------------------------- FONCTION GÃ‰NÃ‰RIQUE DE TRAITEMENT DE DONNÃ‰ES -----------#
#----------------------------------------------------------------------------------#

#' Generic function to process dashboard data
process_dashboard_data <- function(params, appName, excludePattern = NULL) {
  appSelected <- params$runInfo$appSelected
  run_date <- params$runInfo$runDate
  environment <- params$environment

  engine_output <- fread(path_admin_param_engine_output, sep = global_separator)
  tempOutput <- engine_output[tolower(gsub_underscore_dash(" ", "_", engine_output$app)) == tolower(gsub_underscore_dash(" ", "_", appSelected)),]
  files <- tempOutput[tolower(tempOutput$type) == "file", ]
  files$tableaddress <- sprintf(as.character(files$tableaddress), run_date)
  if (!is.null(excludePattern)) {
    files <- files[!grepl(excludePattern, tolower(files$output)), ]
  }

  prod_path <- paste0(foundationRuns_dbfs_root_path, "/", gsub_underscore_dash(" ", "_", tolower(appSelected)), "/", environment, "/Outputs/", run_date)
  data <- list()
  j <- 1
  for(i in 1:nrow(files)){
    file_path <- file.path(prod_path, files$tableaddress[i])
    if(grepl(".csv", file_path)){
      data[[j]] <- fread(file_path, sep = global_separator)
      names(data)[j] <- files$output[i]
    }
    j <- j + 1
  }
  return(data)
}

# Wrapper functions for backward compatibility
process_dashboard_risk_framework_liquidity <- function(params) {
  process_dashboard_data(params, "rf_liquidity", "awa")
}

process_dashboard_ip_local_main <- function(params) {
  process_dashboard_data(params, "ip_local", "awa")
}

process_dashboard_am_fees_report <- function(params) {
  process_dashboard_data(params, "am_fees")
}

#----------------------------------------------------------------------------------#
#------------------------- FONCTIONS GÃ‰NÃ‰RIQUES DE PLOTS -------------------------#
#----------------------------------------------------------------------------------#

#' Generic bar plot function - Returns plotly object only
createGenericBarPlot <- function(xVar, yVar, colorVar = NULL, title = "Bar Plot", 
                                xTitle = "", yTitle = "", height = 400, 
                                textVar = NULL, hoverinfo = "text+y", 
                                orientation = "v", barmode = "group") {
  function(df, tab_id, tokenUI) {
    req(df[[xVar]], df[[yVar]])
    
    p <- plot_ly(df, 
                 x = if(orientation == "v") as.formula(paste0("~", xVar)) else as.formula(paste0("~", yVar)),
                 y = if(orientation == "v") as.formula(paste0("~", yVar)) else as.formula(paste0("~", xVar)),
                 type = "bar",
                 orientation = orientation)
    
    if (!is.null(colorVar) && colorVar %in% names(df)) {
      p <- p %>% add_trace(color = as.formula(paste0("~", colorVar)))
    }
    
    if (!is.null(textVar) && textVar %in% names(df)) {
      p <- p %>% add_trace(text = as.formula(paste0("~", textVar)), hoverinfo = hoverinfo)
    }
    
    p %>% layout(
      title = title,
      xaxis = list(title = if(orientation == "v") xTitle else yTitle),
      yaxis = list(title = if(orientation == "v") yTitle else xTitle),
      barmode = barmode,
      paper_bgcolor = 'rgba(0,0,0,0)',
      plot_bgcolor = 'rgba(0,0,0,0)'
    )
  }
}

#' Generic pie plot function - Returns plotly object only
createGenericPiePlot <- function(labelsVar, valuesVar, title = "Pie Chart", 
                                height = 400, textinfo = "label+percent", 
                                hoverinfo = "label+value+percent", showlegend = TRUE) {
  function(df, tab_id, tokenUI) {
    req(df[[labelsVar]], df[[valuesVar]])
    plot_ly(df,
      labels = as.formula(paste0("~", labelsVar)),
      values = as.formula(paste0("~", valuesVar)),
      type = "pie",
      textinfo = textinfo,
      hoverinfo = hoverinfo
    ) %>%
      layout(title = title, showlegend = showlegend) %>%
      layout(paper_bgcolor = 'rgba(0,0,0,0)', plot_bgcolor = 'rgba(0,0,0,0)')
  }
}

#' Generic waterfall plot function - Returns plotly object only
createGenericWaterfallPlot <- function(labelVar, valueVar, title = "Waterfall Chart", 
                                      xTitle = "", yTitle = "", height = 400,
                                      valueTransform = function(x) x, 
                                      addTotal = TRUE, totalLabel = "Total") {
  function(df, tab_id, tokenUI) {
    req(df[[labelVar]], df[[valueVar]])
    
    df_agg <- df %>%
      dplyr::group_by(!!sym(labelVar)) %>%
      dplyr::summarise(Value = sum(!!sym(valueVar), na.rm = TRUE)) %>%
      dplyr::mutate(Value = valueTransform(Value)) %>%
      dplyr::arrange(desc(abs(Value))) %>%
      dplyr::mutate(
        prefix = paste0(LETTERS[seq_along(!!sym(labelVar))], ". "),
        label = paste0(prefix, !!sym(labelVar)),
        measure = "relative",
        text = format(Value, big.mark = " ")
      )
    
    if (addTotal) {
      total <- data.frame(
        label = totalLabel,
        Value = sum(df_agg$Value, na.rm = TRUE),
        measure = "total",
        text = format(sum(df_agg$Value, na.rm = TRUE), big.mark = " ")
      )
      df_waterfall <- dplyr::bind_rows(df_agg[, c("label", "Value", "measure", "text")], total)
    } else {
      df_waterfall <- df_agg[, c("label", "Value", "measure", "text")]
    }
    
    plot_ly(df_waterfall, type = "waterfall", x = ~label, y = ~Value, text = ~text,
            measure = ~measure, textposition = "outside",
            connector = list(line = list(color = "rgba(63, 63, 63, 0.7)"))) %>%
      layout(title = title, xaxis = list(title = xTitle, tickangle = -45),
             yaxis = list(title = yTitle), paper_bgcolor = 'rgba(0,0,0,0)',
             plot_bgcolor = 'rgba(0,0,0,0)')
  }
}

#' Generic line plot function - Returns plotly object only
createGenericLinePlot <- function(xVar, yVar, colorVar = NULL, title = "Line Plot", 
                                 xTitle = "", yTitle = "", height = 400,
                                 lineType = "lines", mode = "lines+markers") {
  function(df, tab_id, tokenUI) {
    req(df[[xVar]], df[[yVar]])
    
    p <- plot_ly(df, 
                 x = as.formula(paste0("~", xVar)),
                 y = as.formula(paste0("~", yVar)),
                 type = "scatter",
                 mode = mode,
                 line = list(shape = lineType))
    
    if (!is.null(colorVar) && colorVar %in% names(df)) {
      p <- p %>% add_trace(color = as.formula(paste0("~", colorVar)))
    }
    
    p %>% layout(
      title = title,
      xaxis = list(title = xTitle),
      yaxis = list(title = yTitle),
      paper_bgcolor = 'rgba(0,0,0,0)',
      plot_bgcolor = 'rgba(0,0,0,0)'
    )
  }
}

#' Generic scatter plot function - Returns plotly object only
createGenericScatterPlot <- function(xVar, yVar, colorVar = NULL, sizeVar = NULL, 
                                    title = "Scatter Plot", xTitle = "", yTitle = "", 
                                    height = 400, mode = "markers") {
  function(df, tab_id, tokenUI) {
    req(df[[xVar]], df[[yVar]])
    
    p <- plot_ly(df, 
                 x = as.formula(paste0("~", xVar)),
                 y = as.formula(paste0("~", yVar)),
                 type = "scatter",
                 mode = mode)
    
    if (!is.null(colorVar) && colorVar %in% names(df)) {
      p <- p %>% add_trace(color = as.formula(paste0("~", colorVar)))
    }
    
    if (!is.null(sizeVar) && sizeVar %in% names(df)) {
      p <- p %>% add_trace(size = as.formula(paste0("~", sizeVar)))
    }
    
    p %>% layout(
      title = title,
      xaxis = list(title = xTitle),
      yaxis = list(title = yTitle),
      paper_bgcolor = 'rgba(0,0,0,0)',
      plot_bgcolor = 'rgba(0,0,0,0)'
    )
  }
}

#' Generic histogram function - Returns plotly object only
createGenericHistogram <- function(xVar, title = "Histogram", xTitle = "", yTitle = "Count", 
                                  height = 400, bins = NULL, colorVar = NULL) {
  function(df, tab_id, tokenUI) {
    req(df[[xVar]])
    
    p <- plot_ly(df, 
                 x = as.formula(paste0("~", xVar)),
                 type = "histogram",
                 nbinsx = bins)
    
    if (!is.null(colorVar) && colorVar %in% names(df)) {
      p <- p %>% add_trace(color = as.formula(paste0("~", colorVar)))
    }
    
    p %>% layout(
      title = title,
      xaxis = list(title = xTitle),
      yaxis = list(title = yTitle),
      paper_bgcolor = 'rgba(0,0,0,0)',
      plot_bgcolor = 'rgba(0,0,0,0)'
    )
  }
}

#' Generic box plot function - Returns plotly object only
createGenericBoxPlot <- function(yVar, xVar = NULL, colorVar = NULL, title = "Box Plot", 
                                xTitle = "", yTitle = "", height = 400) {
  function(df, tab_id, tokenUI) {
    req(df[[yVar]])
    
    if (!is.null(xVar) && xVar %in% names(df)) {
      p <- plot_ly(df, 
                   x = as.formula(paste0("~", xVar)),
                   y = as.formula(paste0("~", yVar)),
                   type = "box")
    } else {
      p <- plot_ly(df, 
                   y = as.formula(paste0("~", yVar)),
                   type = "box")
    }
    
    if (!is.null(colorVar) && colorVar %in% names(df)) {
      p <- p %>% add_trace(color = as.formula(paste0("~", colorVar)))
    }
    
    p %>% layout(
      title = title,
      xaxis = list(title = xTitle),
      yaxis = list(title = yTitle),
      paper_bgcolor = 'rgba(0,0,0,0)',
      plot_bgcolor = 'rgba(0,0,0,0)'
    )
  }
}

#' Generic heatmap function - Returns plotly object only
createGenericHeatmap <- function(xVar, yVar, zVar, title = "Heatmap", 
                                xTitle = "", yTitle = "", height = 400) {
  function(df, tab_id, tokenUI) {
    req(df[[xVar]], df[[yVar]], df[[zVar]])
    
    plot_ly(df, 
            x = as.formula(paste0("~", xVar)),
            y = as.formula(paste0("~", yVar)),
            z = as.formula(paste0("~", zVar)),
            type = "heatmap") %>%
      layout(
        title = title,
        xaxis = list(title = xTitle),
        yaxis = list(title = yTitle),
        paper_bgcolor = 'rgba(0,0,0,0)',
        plot_bgcolor = 'rgba(0,0,0,0)'
      )
  }
}

#' Generic multi-trace plot function - Returns plotly object only
createGenericMultiTracePlot <- function(traces, title = "Multi-Trace Plot", 
                                       xTitle = "", yTitle = "", height = 400,
                                       barmode = "group", orientation = "v") {
  function(df, tab_id, tokenUI) {
    p <- plot_ly()
    
    for (trace in traces) {
      p <- p %>% add_trace(
        x = trace$x,
        y = trace$y,
        type = trace$type,
        name = trace$name,
        marker = trace$marker,
        text = trace$text,
        hoverinfo = trace$hoverinfo,
        orientation = orientation
      )
    }
    
    p %>% layout(
      title = title,
      xaxis = list(title = xTitle),
      yaxis = list(title = yTitle),
      barmode = barmode,
      paper_bgcolor = 'rgba(0,0,0,0)',
      plot_bgcolor = 'rgba(0,0,0,0)'
    )
  }
}

#----------------------------------------------------------------------------------#
#------------------------- FONCTION GÃ‰NÃ‰RIQUE DASHBOARD UI -----------------------#
#----------------------------------------------------------------------------------#

#' Generic Dashboard UI Creator
createGenericDashboardUI <- function(id, reactiveReportObject, appName, user = "", tokenUI = "", config = list()) {
  ns <- NS(id)
  
  # Default configuration
  defaultConfig <- list(
    appName = appName,
    reportName = paste0(appName, "_Report"),
    csvDownloadLabel = "ðŸ“¥ Download all the file in CSV",
    showExcelDownload = TRUE,
    showTotals = TRUE,
    tableTypes = "DT",
    totalPatterns = NULL,
    percentageCols = NULL,
    tableOptions = list(paging = FALSE, dom = 'tip', autoWidth = TRUE, ordering = TRUE),
    filterPosition = "top",
    successRedirect = paste0("#", appName),
    errorMessage = "Error loading data",
    plots = list(),
    customControls = list(),
    dataFilter = function(data_list) data_list
  )
  
  # Merge with user config
  config <- modifyList(defaultConfig, config)
  
  observe({
    req(reactiveReportObject$app)
    appSelected <- reactiveReportObject$app
    if (!tolower(gsub_underscore_dash(" ", "_", appSelected)) %in% c(tolower(gsub_underscore_dash(" ", "_", appName)))) {
      return()
    }

    showPageSpinner()
    tryCatch({
      # Cleanup previous content
      removeUI(selector = paste0("#", id, "ContentAnalysis"), immediate = TRUE)

      data_list <- reactiveReportObject$reportData
      if (is.null(data_list)) {
        hidePageSpinner()
        return()
      }
      if (!is.list(data_list)) {
        data_list <- list(data_list)
        names(data_list) <- c("Report")
      }

      # Apply data filter if provided
      data_list <- config$dataFilter(data_list)

      # Build tabs
      tabs <- Map(function(i) list(id = paste0(id, "-", i, "_", tokenUI), name = names(data_list)[i]), seq_len(length(data_list)))

      ui_root <- tags$div(
        id = paste0(id, "ContentAnalysis"),
        class = "row",
        tags$div(class = "col-12 mb-2",
          downloadButton(ns(paste0("download_all_data_excel_", tokenUI)), config$csvDownloadLabel, class = "btn btn-primary my-2")
        ),
        tags$div(class = "col-12", Generate_dashboard_tabs_table(tabs))
      )

      insertUI(selector = paste0("#", id, "Content"), ui = ui_root, immediate = TRUE)

      # Populate each tab content
      for (i in seq_along(data_list)) {
        local({
          idx <- i
          df <- data_list[[idx]]
          table_name <- names(data_list)[idx]

          tab_id <- paste0(id, "-", idx, "_", tokenUI)

          # Add per-tab controls (download + plots container) above the DT
          insertUI(
            selector = paste0("#nav-", tab_id),
            where = "afterBegin",
            ui = tags$div(
              class = "my-3",
              fluidRow(
                column(12, class = "d-flex justify-content-between align-items-center mb-2",
                  downloadButton(outputId = paste0("download_", tab_id, "_", tokenUI), label = "ðŸ“¥ Download CSV", class = "btn btn-sm btn-success")
                )
              ),
              tags$div(id = paste0("plots_", tab_id))
            )
          )

          # Add custom controls if any
          if (length(config$customControls) > 0) {
            for (control_config in config$customControls) {
              if (grepl(control_config$pattern, gsub_underscore_dash(" ", "_", tolower(table_name)))) {
                insertUI(selector = paste0("#", paste0("plots_", tab_id)), where = "beforeEnd", ui = control_config$ui)
                
                # Execute custom control logic
                if (!is.null(control_config$logic)) {
                  control_config$logic(df, table_name, tab_id, tokenUI)
                }
              }
            }
          }

          # Add plots based on configuration
          if (length(config$plots) > 0) {
            for (plot_config in config$plots) {
              if (grepl(plot_config$pattern, gsub_underscore_dash(" ", "_", tolower(table_name)))) {
                # Call UI function with parameters if it's a function, otherwise use as is
                ui_content <- if (is.function(plot_config$ui)) {
                  plot_config$ui(tab_id, tokenUI)
                } else {
                  plot_config$ui
                }
                insertUI(selector = paste0("#", paste0("plots_", tab_id)), where = "beforeEnd", ui = ui_content)
                
                # Add plot logic - CORRECTION PRINCIPALE ICI
                for (plot_name in names(plot_config$plots)) {
                  plot_spec <- plot_config$plots[[plot_name]]
                  if (is.function(plot_spec)) {
                    # plot_spec is a function that returns plotly object, so wrap it in renderPlotly
                    output[[paste0(plot_name, "_", tab_id, "_", tokenUI)]] <- renderPlotly({
                      plot_spec(df, tab_id, tokenUI)
                    })
                  } else if (is.list(plot_spec) && !is.null(plot_spec$renderer)) {
                    output[[paste0(plot_name, "_", tab_id, "_", tokenUI)]] <- plot_spec$renderer(df, tab_id, tokenUI)
                  } else {
                    output[[paste0(plot_name, "_", tab_id, "_", tokenUI)]] <- plot_spec
                  }
                }
              }
            }
          }

          # Handle special table types
          if (grepl("interface_alloc", gsub_underscore_dash(" ", "_", tolower(table_name)))) {
            boolDfToShow <- FALSE
            # This will be handled by custom controls logic
          } else {
            boolDfToShow <- TRUE
          }

          # Table rendering
          if (boolDfToShow) {
            # Determine table type dynamically
            table_type <- if (is.function(config$tableTypes)) {
              config$tableTypes(data_list, table_name, df)
            } else if (is.character(config$tableTypes) && length(config$tableTypes) == 1) {
              config$tableTypes
            } else if (is.character(config$tableTypes) && length(config$tableTypes) == length(data_list)) {
              config$tableTypes[idx]
            } else {
              "DT"  # Default fallback
            }
            
            if (table_type == "DT") {
              output[[paste0("td_dashboard_", tab_id)]] <- renderDT({
                num_cols <- names(df)[sapply(df, is.numeric)]
                df_clean <- df
                
                # Determine if totals should be shown
                show_total <- FALSE
                if (config$showTotals) {
                  if (is.null(config$totalPatterns)) {
                    # Auto-detect based on data content and table characteristics
                    has_numeric_cols <- any(sapply(df, is.numeric))
                    has_multiple_rows <- nrow(df) > 1
                    has_summary_indicators <- any(grepl("total|sum|aggregate|summary|amount|value|count", tolower(names(df))))
                    table_name_suggests_totals <- grepl("report|summary|total|aggregate|calcul|kpi|intermediate|weighted|stress", 
                                                      gsub_underscore_dash(" ", "_", tolower(table_name)))
                    
                    show_total <- has_numeric_cols && has_multiple_rows && (has_summary_indicators || table_name_suggests_totals)
                  } else if (is.function(config$totalPatterns)) {
                    show_total <- config$totalPatterns(table_name, df)
                  } else {
                    show_total <- any(sapply(config$totalPatterns, function(pattern) {
                      grepl(pattern, gsub_underscore_dash(" ", "_", tolower(table_name)))
                    }))
                  }
                }
                
                if (show_total && length(num_cols) > 0) {
                  total_row <- df_clean[, lapply(.SD, function(x) if (is.numeric(x)) sum(x, na.rm = TRUE) else NA), .SDcols = num_cols]
                  total_row[, setdiff(names(df_clean), num_cols) := lapply(setdiff(names(df_clean), num_cols), function(x) "Total")]
                  df_clean <- rbind(df_clean, total_row, fill = TRUE)
                }
                
                dt <- datatable(df_clean, rownames = FALSE, options = config$tableOptions, filter = config$filterPosition)
                
                # Determine percentage columns dynamically
                percentage_cols <- if (is.null(config$percentageCols)) {
                  # Auto-detect percentage columns based on data content and column names
                  numeric_cols <- names(df)[sapply(df, is.numeric)]
                  
                  # Check column names for percentage indicators
                  name_indicators <- grepl("weight|percent|rate|ratio|pct|share|allocation|distribution", tolower(numeric_cols))
                  
                  # Check data content for percentage-like values (0-1 range or 0-100 range)
                  content_indicators <- sapply(numeric_cols, function(col) {
                    values <- df[[col]]
                    if (length(values) == 0) return(FALSE)
                    # Check if values are in percentage range (0-1 or 0-100)
                    all_values <- values[!is.na(values)]
                    if (length(all_values) == 0) return(FALSE)
                    max_val <- max(all_values, na.rm = TRUE)
                    min_val <- min(all_values, na.rm = TRUE)
                    # Values between 0-1 or 0-100 with reasonable distribution
                    (max_val <= 1.1 && min_val >= -0.1) || (max_val <= 110 && min_val >= -10 && max_val > 1)
                  })
                  
                  # Combine name and content indicators
                  numeric_cols[name_indicators | content_indicators]
                } else if (is.function(config$percentageCols)) {
                  config$percentageCols(df)
                } else {
                  config$percentageCols
                }
                
                # Apply formatting
                for (col in num_cols) {
                  if (col %in% percentage_cols) {
                    dt <- DT::formatPercentage(dt, columns = col, digits = 2)
                  } else {
                    dt <- DT::formatCurrency(dt, columns = col, currency = "", digits = 0, interval = 3, mark = " ")
                  }
                }
                
                if (show_total) {
                  dt <- DT::formatStyle(dt, columns = 0, target = "row", rows = nrow(df_clean), fontWeight = "bold", backgroundColor = "#f9f9f9")
                }
                dt
              })
            } else if (table_type == "RHandsontable") {
              output[[paste0("td_dashboard_", tab_id)]] <- renderRHandsontable({
                rhandsontable(df, readOnly = FALSE, width = "100%", height = 400) %>%
                  hot_cols(columnSorting = TRUE) %>%
                  hot_context_menu(allowRowEdit = TRUE, allowColEdit = TRUE)
              })
            }
          }

          # Downloads
          output[[paste0("download_", tab_id, "_", tokenUI)]] <- downloadHandler(
            filename = function() paste0(gsub("[\\/:*?\"<>|]", "_", table_name), ".csv"),
            content = function(file) {
              fwrite(df, file, row.names = FALSE, sep = user_separator(), quote = TRUE)
            }
          )
        })
      }

      # Download all to Excel
      if (config$showExcelDownload) {
        output[[ns(paste0("download_all_data_excel_", tokenUI))]] <- downloadHandler(
          filename = function() paste0(config$reportName, "_", Sys.Date(), ".xlsx"),
          content = function(file) {
            openxlsx::write.xlsx(data_list, file)
          }
        )
      }

      hidePageSpinner()
      runjs(paste0("$('a[href=\"", config$successRedirect, "\"]').click();"))
    }, error = function(e) {
      print(e)
      hidePageSpinner()
      runjs(paste0("toastr.error('", config$errorMessage, "','',toastr.options.timeOut='500');"))
    })
  })
}

#----------------------------------------------------------------------------------#
#------------------------- FONCTIONS SPÃ‰CIALISÃ‰ES --------------------------------#
#----------------------------------------------------------------------------------#

#' Create RFLiquidity UI using the generic function
createRFLiquidityUI <- function(id, reactiveReportObject, user = "", tokenUI = "") {
  config <- list(
    appName = "rf_liquidity",
    reportName = "RiskFrameworkLiquidity_Report",
    tableTypes = "DT",
    totalPatterns = c("intermediate_report", "weighted", "stress_impact"),
    percentageCols = c("lrm_weight", "Impact Weighted Resource"),
    plots = list(
      # Intermediate report plots
      list(
        pattern = "intermediate_report",
        ui = function(tab_id, tokenUI) {
          fluidRow(
            column(12, class = "col-12 col-md-4", plotlyOutput(outputId = paste0("plot_impact_", tab_id, "_", tokenUI), height = "550px")),
            column(12, class = "col-12 col-md-4", plotlyOutput(outputId = paste0("plot_waterfall_", tab_id, "_", tokenUI), height = "550px")),
            column(12, class = "col-12 col-md-4", plotlyOutput(outputId = paste0("plot_pie_", tab_id, "_", tokenUI), height = "550px"))
          )
        },
        plots = list(
          plot_impact = function(df, tab_id, tokenUI) {
            req(df$lrm_classification, df$Ressources_before_haircut)
            plot_ly(df,
              x = ~lrm_classification,
              y = ~Ressources_before_haircut,
              type = "bar",
              text = ~scales::percent(Ressources_before_haircut, accuracy = 0.1),
              hoverinfo = "text+y",
              color = ~lrm_classification
            ) %>%
            layout(title = "Resources before haircut", xaxis = list(title = ""), yaxis = list(title = "Impact (%)")) %>%
            layout(paper_bgcolor = 'rgba(0,0,0,0)', plot_bgcolor = 'rgba(0,0,0,0)')
          },
          plot_waterfall = function(df, tab_id, tokenUI) {
            req(df$lrm_classification, df$Financial_Impact)
            df_agg <- df %>%
              dplyr::group_by(lrm_classification) %>%
              dplyr::summarise(Financial_Impact = sum(-Financial_Impact, na.rm = TRUE)) %>%
              dplyr::arrange(desc(abs(Financial_Impact))) %>%
              dplyr::mutate(
                prefix = paste0(LETTERS[seq_along(lrm_classification)], ". "),
                label = paste0(prefix, lrm_classification),
                measure = "relative",
                text = format(Financial_Impact, big.mark = " ")
              )
            total <- data.frame(
              label = "Total",
              Financial_Impact = sum(df_agg$Financial_Impact, na.rm = TRUE),
              measure = "total",
              text = format(sum(df_agg$Financial_Impact, na.rm = TRUE), big.mark = " ")
            )
            df_waterfall <- dplyr::bind_rows(df_agg[, c("label", "Financial_Impact", "measure", "text")], total)
            plot_ly(
              df_waterfall,
              type = "waterfall",
              x = ~label,
              y = ~Financial_Impact,
              text = ~text,
              measure = ~measure,
              textposition = "outside",
              connector = list(line = list(color = "rgba(63, 63, 63, 0.7)"))
            ) %>%
              layout(
                title = "Financial Impact",
                xaxis = list(title = "", tickangle = -45),
                yaxis = list(title = "Financial Impact (â‚¬)"),
                paper_bgcolor = 'rgba(0,0,0,0)',
                plot_bgcolor = 'rgba(0,0,0,0)'
              )
          },
          plot_pie = function(df, tab_id, tokenUI) {
            req(df$lrm_classification, df$Weighted_resources_after_encumbrance)
            plot_ly(
              df,
              labels = ~lrm_classification,
              values = ~abs(Weighted_resources_after_encumbrance),
              type = "pie",
              textinfo = "label+percent",
              hoverinfo = "label+value+percent"
            ) %>%
              layout(title = "Weighted Resources After Encumbrance", showlegend = TRUE) %>%
              layout(paper_bgcolor = 'rgba(0,0,0,0)', plot_bgcolor = 'rgba(0,0,0,0)')
          }
        )
      ),
      # Stress impact report plots
      list(
        pattern = "stress_impact_report",
        ui = function(tab_id, tokenUI) {
          fluidRow(
            column(12, class = "col-12 col-md-4 offset-md-4", plotlyOutput(outputId = paste0("plot_pie_", tab_id, "_", tokenUI), height = "550px"))
          )
        },
        plots = list(
          plot_pie = function(df, tab_id, tokenUI) {
            req(df$risk_module, df$external_figures)
            plot_ly(
              df,
              labels = ~risk_module,
              values = ~abs(external_figures),
              type = "pie",
              textinfo = "label+percent",
              hoverinfo = "label+value+percent"
            ) %>%
              layout(title = "External Figures", showlegend = TRUE) %>%
              layout(paper_bgcolor = 'rgba(0,0,0,0)', plot_bgcolor = 'rgba(0,0,0,0)')
          }
        )
      ),
      # Liquidity report plots
      list(
        pattern = "liquidity_report",
        ui = function(tab_id, tokenUI) {
          fluidRow(
            column(12, plotlyOutput(outputId = paste0("plot_liquidity_", tab_id, "_", tokenUI), height = "200px"))
          )
        },
        plots = list(
          plot_liquidity = function(df, tab_id, tokenUI) {
            df_vals <- df %>%
              dplyr::filter(get(names(df)[1]) %in% c("Excess liquidity", "Stress impact", "Available weighted resources")) %>%
              tidyr::pivot_wider(names_from = names(df)[1], values_from = `New methodology`) %>%
              dplyr::mutate(stress = `Stress impact`, excess = `Excess liquidity`)
            
            traces <- list(
              list(
                type = "bar",
                x = df_vals$`Stress impact`,
                y = "Available weighted resources",
                name = "Stress impact",
                marker = list(color = 'rgba(255, 99, 71, 0.8)'),
                text = format(df_vals$`Stress impact`, big.mark = " "),
                hoverinfo = "text+x"
              ),
              list(
                type = "bar",
                x = df_vals$`Excess liquidity`,
                y = "Available weighted resources",
                name = "Excess liquidity",
                marker = list(color = 'rgba(0, 200, 0, 0.7)'),
                text = format(df_vals$`Excess liquidity`, big.mark = " "),
                hoverinfo = "text+x"
              )
            )
            
            createGenericMultiTracePlot(
              traces = traces,
              title = "",
              xTitle = "Amount (mEUR)",
              yTitle = "",
              height = 200,
              barmode = "stack",
              orientation = "h"
            )(df, tab_id, tokenUI)
          }
        )
      )
    )
  )
  
  createGenericDashboardUI(id, reactiveReportObject, "rf_liquidity", user, tokenUI, config)
}

#' Create IPLocalMain UI using the generic function
createIPLocalMainUI <- function(id, reactiveReportObject, user = "", tokenUI = "") {
  config <- list(
    appName = "ip_local",
    reportName = "IPLocalMain_Report",
    csvDownloadLabel = "ðŸ“¥ Download all the file in CSV",
    dataFilter = function(data_list) {
      data_list[grepl("interface", gsub_underscore_dash(" ", "_", tolower(names(data_list))))]
    },
    tableTypes = function(data_list, table_name, df) {
      if (grepl("interface_alloc", gsub_underscore_dash(" ", "_", tolower(table_name)))) {
        "RHandsontable"
      } else {
        "DT"
      }
    },
    totalPatterns = c("intermediate_report", "weighted", "stress_impact"),
    percentageCols = c("lrm_weight", "Impact Weighted Resource"),
    customControls = list(
      list(
        pattern = "interface_alloc",
        ui = fluidRow(
          column(12, class = "col-12 col-md-4", customSelectWithValues(inputId = "selector_portfolios_alloc", label = "Select a portfolio", icon = "briefcase", message = "Select a portfolio", options = NULL, labels = NULL, multiple = FALSE, disabled = FALSE, selected = NULL)),
          column(12, class = "col-12 col-md-4", customSelectWithValues(inputId = "selector_source_type_alloc", label = "Select a source type", icon = "briefcase", message = "Select a source type", options = NULL, labels = NULL, multiple = FALSE, disabled = FALSE, selected = NULL)),
          column(12, class = "col-12 col-md-4", actionButton(inputId = "action_button_alloc", label = "Generate", class = "btn btn-sm btn-success btn-rounded foundation-btn-primary"))
        ),
        logic = function(df, table_name, tab_id, tokenUI) {
          portefeuilles <- unique(df$portefeuille)
          source_types <- unique(df$source_type)
          
          updateCustomSelectWithValues(session, "selector_portfolios_alloc", options = portefeuilles, labels = portefeuilles)
          updateCustomSelectWithValues(session, "selector_source_type_alloc", options = source_types, labels = source_types)
          
          observeEvent(input$action_button_alloc, {
            req(input$selector_portfolios_alloc, input$selector_source_type_alloc)
            df <- as.data.table(df)
            df_filtered <- df[portefeuille == input$selector_portfolios_alloc & source_type == input$selector_source_type_alloc,]
            df_filtered$portefeuille <- NULL
            df_filtered$source_type <- NULL
            
            value_vars <- setdiff(names(df_filtered), c("portefeuille", "source_type", "year", "SAA Asset Class", "Level 4", "Currency"))
            
            casted_list <- lapply(value_vars, function(vv) {
              dcast(df_filtered, formula = as.formula(paste("`SAA Asset Class` + `Level 4` + Currency ~ year")),
                    value.var = vv, fun.aggregate = function(x) {
                      if (length(x) == 0) { NA } else if (all(is.na(x))) { NA } else if (is.numeric(x)) { sum(x, na.rm = TRUE) } else { x[!is.na(x)][1] }
                    })
            })
            names(casted_list) <- value_vars
            df_final <- Reduce(function(x, y) merge(x, y, by = c("SAA Asset Class", "Level 4", "Currency"), all = TRUE, suffixes = c("", ".y")), casted_list)
            output[[paste0("td_dashboard_", tab_id)]] <- renderRHandsontable({
              rhandsontable(df_final, readOnly = FALSE, width = "100%", height = 400) %>%
                hot_cols(columnSorting = TRUE) %>%
                hot_context_menu(allowRowEdit = TRUE, allowColEdit = TRUE)
            })
          })
        }
      )
    )
  )
  
  createGenericDashboardUI(id, reactiveReportObject, "ip_local", user, tokenUI, config)
}

#' Create AMFees UI using the generic function
createAMFeesUI <- function(id, reactiveReportObject, user = "", tokenUI = "") {
  config <- list(
    appName = "am_fees",
    reportName = "AMFees_Report",
    tableTypes = "DT",
    totalPatterns = c("calcul_report", "kpi_axa_im_report"),
    percentageCols = c("lrm_weight", "Impact Weighted Resource")
  )
  
  createGenericDashboardUI(id, reactiveReportObject, "am_fees", user, tokenUI, config)
}
