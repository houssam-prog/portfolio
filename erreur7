#----------------------------------------------------------------------------------#
#------------------------- SOLUTION GÉNÉRIQUE COMPLÈTEMENT FACTORISÉE ------------#
#----------------------------------------------------------------------------------#

#----------------------------------------------------------------------------------#
#------------------------- FONCTION GÉNÉRIQUE DE TRAITEMENT DE DONNÉES -----------#
#----------------------------------------------------------------------------------#

#' Generic function to process dashboard data
process_dashboard_data <- function(params, appName, excludePattern = NULL) {
  appSelected <- params$runInfo$appSelected
  run_date <- params$runInfo$runDate
  environment <- params$environment

  engine_output <- fread(path_admin_param_engine_output, sep = global_separator)
  tempOutput <- engine_output[tolower(gsub_underscore_dash(" ", "_", engine_output$app)) == tolower(gsub_underscore_dash(" ", "_", appSelected)),]
  files <- tempOutput[tolower(tempOutput$type) == "file", ]
  files$tableaddress <- sprintf(as.character(files$tableaddress), run_date)
  if (!is.null(excludePattern)) {
    files <- files[!grepl(excludePattern, tolower(files$output)), ]
  }

  prod_path <- paste0(foundationRuns_dbfs_root_path, "/", gsub_underscore_dash(" ", "_", tolower(appSelected)), "/", environment, "/Outputs/", run_date)
  data <- list()
  j <- 1
  for(i in 1:nrow(files)){
    file_path <- file.path(prod_path, files$tableaddress[i])
    if(grepl(".csv", file_path)){
      data[[j]] <- fread(file_path, sep = global_separator)
      names(data)[j] <- files$output[i]
    }
    j <- j + 1
  }
  return(data)
}

# Wrapper functions for backward compatibility
process_dashboard_risk_framework_liquidity <- function(params) {
  process_dashboard_data(params, "rf_liquidity", "awa")
}

process_dashboard_ip_local_main <- function(params) {
  process_dashboard_data(params, "ip_local", "awa")
}

process_dashboard_am_fees_report <- function(params) {
  process_dashboard_data(params, "am_fees")
}

#----------------------------------------------------------------------------------#
#------------------------- FONCTIONS GÉNÉRIQUES DE PLOTS -------------------------#
#----------------------------------------------------------------------------------#

#' Generic bar plot function - Returns plotly object only
createGenericBarPlot <- function(xVar, yVar, colorVar = NULL, title = "Bar Plot", 
                                xTitle = "", yTitle = "", height = 400, 
                                textVar = NULL, hoverinfo = "text+y", 
                                orientation = "v", barmode = "group") {
  function(df) {
    req(df[[xVar]], df[[yVar]])
    
    p <- plot_ly(df, 
                 x = if(orientation == "v") as.formula(paste0("~", xVar)) else as.formula(paste0("~", yVar)),
                 y = if(orientation == "v") as.formula(paste0("~", yVar)) else as.formula(paste0("~", xVar)),
                 type = "bar",
                 orientation = orientation)
    
    if (!is.null(colorVar) && colorVar %in% names(df)) {
      p <- p %>% add_trace(color = as.formula(paste0("~", colorVar)))
    }
    
    if (!is.null(textVar) && textVar %in% names(df)) {
      p <- p %>% add_trace(text = as.formula(paste0("~", textVar)), hoverinfo = hoverinfo)
    }
    
    p %>% layout(
      title = title,
      xaxis = list(title = if(orientation == "v") xTitle else yTitle),
      yaxis = list(title = if(orientation == "v") yTitle else xTitle),
      barmode = barmode,
      paper_bgcolor = 'rgba(0,0,0,0)',
      plot_bgcolor = 'rgba(0,0,0,0)'
    )
  }
}

#' Generic pie plot function - Returns plotly object only
createGenericPiePlot <- function(labelsVar, valuesVar, title = "Pie Chart", 
                                height = 400, textinfo = "label+percent", 
                                hoverinfo = "label+value+percent", showlegend = TRUE) {
  function(df) {
    req(df[[labelsVar]], df[[valuesVar]])
    plot_ly(df,
      labels = as.formula(paste0("~", labelsVar)),
      values = as.formula(paste0("~", valuesVar)),
      type = "pie",
      textinfo = textinfo,
      hoverinfo = hoverinfo
    ) %>%
      layout(title = title, showlegend = showlegend) %>%
      layout(paper_bgcolor = 'rgba(0,0,0,0)', plot_bgcolor = 'rgba(0,0,0,0)')
  }
}

#' Generic waterfall plot function - Returns plotly object only
createGenericWaterfallPlot <- function(labelVar, valueVar, title = "Waterfall Chart", 
                                      xTitle = "", yTitle = "", height = 400,
                                      valueTransform = function(x) x, 
                                      addTotal = TRUE, totalLabel = "Total") {
  function(df) {
    req(df[[labelVar]], df[[valueVar]])
    
    df_agg <- df %>%
      dplyr::group_by(!!sym(labelVar)) %>%
      dplyr::summarise(Value = sum(!!sym(valueVar), na.rm = TRUE)) %>%
      dplyr::mutate(Value = valueTransform(Value)) %>%
      dplyr::arrange(desc(abs(Value))) %>%
      dplyr::mutate(
        prefix = paste0(LETTERS[seq_along(!!sym(labelVar))], ". "),
        label = paste0(prefix, !!sym(labelVar)),
        measure = "relative",
        text = format(Value, big.mark = " ")
      )
    
    if (addTotal) {
      total <- data.frame(
        label = totalLabel,
        Value = sum(df_agg$Value, na.rm = TRUE),
        measure = "total",
        text = format(sum(df_agg$Value, na.rm = TRUE), big.mark = " ")
      )
      df_waterfall <- dplyr::bind_rows(df_agg[, c("label", "Value", "measure", "text")], total)
    } else {
      df_waterfall <- df_agg[, c("label", "Value", "measure", "text")]
    }
    
    plot_ly(df_waterfall, type = "waterfall", x = ~label, y = ~Value, text = ~text,
            measure = ~measure, textposition = "outside",
            connector = list(line = list(color = "rgba(63, 63, 63, 0.7)"))) %>%
      layout(title = title, xaxis = list(title = xTitle, tickangle = -45),
             yaxis = list(title = yTitle), paper_bgcolor = 'rgba(0,0,0,0)',
             plot_bgcolor = 'rgba(0,0,0,0)')
  }
}

#' Generic line plot function - Returns plotly object only
createGenericLinePlot <- function(xVar, yVar, colorVar = NULL, title = "Line Plot",
                                 xTitle = "", yTitle = "", height = 400,
                                 lineType = "lines", mode = "lines+markers") {
  function(df) {
    req(df[[xVar]], df[[yVar]])
    
    p <- plot_ly(df, 
                 x = as.formula(paste0("~", xVar)), 
                 y = as.formula(paste0("~", yVar)), 
                 type = "scatter",
                 mode = mode)
    
    if (!is.null(colorVar) && colorVar %in% names(df)) {
      p <- p %>% add_trace(color = as.formula(paste0("~", colorVar)))
    }
    
    p %>% layout(
      title = title,
      xaxis = list(title = xTitle),
      yaxis = list(title = yTitle),
      paper_bgcolor = 'rgba(0,0,0,0)',
      plot_bgcolor = 'rgba(0,0,0,0)'
    )
  }
}

#' Generic scatter plot function - Returns plotly object only
createGenericScatterPlot <- function(xVar, yVar, colorVar = NULL, sizeVar = NULL,
                                    title = "Scatter Plot", xTitle = "", yTitle = "",
                                    height = 400, mode = "markers") {
  function(df) {
    req(df[[xVar]], df[[yVar]])
    
    p <- plot_ly(df, 
                 x = as.formula(paste0("~", xVar)), 
                 y = as.formula(paste0("~", yVar)), 
                 type = "scatter",
                 mode = mode)
    
    if (!is.null(colorVar) && colorVar %in% names(df)) {
      p <- p %>% add_trace(color = as.formula(paste0("~", colorVar)))
    }
    
    if (!is.null(sizeVar) && sizeVar %in% names(df)) {
      p <- p %>% add_trace(size = as.formula(paste0("~", sizeVar)))
    }
    
    p %>% layout(
      title = title,
      xaxis = list(title = xTitle),
      yaxis = list(title = yTitle),
      paper_bgcolor = 'rgba(0,0,0,0)',
      plot_bgcolor = 'rgba(0,0,0,0)'
    )
  }
}

#' Generic histogram function - Returns plotly object only
createGenericHistogram <- function(xVar, title = "Histogram", xTitle = "", yTitle = "Count",
                                  height = 400, bins = NULL, color = NULL) {
  function(df) {
    req(df[[xVar]])
    
    p <- plot_ly(df, x = as.formula(paste0("~", xVar)), type = "histogram")
    
    if (!is.null(color)) {
      p <- p %>% add_trace(marker = list(color = color))
    }
    
    if (!is.null(bins)) {
      p <- p %>% add_trace(nbinsx = bins)
    }
    
    p %>% layout(
      title = title,
      xaxis = list(title = xTitle),
      yaxis = list(title = yTitle),
      paper_bgcolor = 'rgba(0,0,0,0)',
      plot_bgcolor = 'rgba(0,0,0,0)'
    )
  }
}

#' Generic box plot function - Returns plotly object only
createGenericBoxPlot <- function(xVar, yVar, title = "Box Plot", xTitle = "", yTitle = "",
                                height = 400, colorVar = NULL) {
  function(df) {
    req(df[[xVar]], df[[yVar]])
    
    p <- plot_ly(df, 
                 x = as.formula(paste0("~", xVar)), 
                 y = as.formula(paste0("~", yVar)), 
                 type = "box")
    
    if (!is.null(colorVar) && colorVar %in% names(df)) {
      p <- p %>% add_trace(color = as.formula(paste0("~", colorVar)))
    }
    
    p %>% layout(
      title = title,
      xaxis = list(title = xTitle),
      yaxis = list(title = yTitle),
      paper_bgcolor = 'rgba(0,0,0,0)',
      plot_bgcolor = 'rgba(0,0,0,0)'
    )
  }
}

#' Generic heatmap function - Returns plotly object only
createGenericHeatmap <- function(xVar, yVar, zVar, title = "Heatmap", 
                                xTitle = "", yTitle = "", height = 400,
                                colorscale = "Viridis") {
  function(df) {
    req(df[[xVar]], df[[yVar]], df[[zVar]])
    
    plot_ly(df, 
            x = as.formula(paste0("~", xVar)), 
            y = as.formula(paste0("~", yVar)), 
            z = as.formula(paste0("~", zVar)),
            type = "heatmap",
            colorscale = colorscale) %>%
      layout(
        title = title,
        xaxis = list(title = xTitle),
        yaxis = list(title = yTitle),
        paper_bgcolor = 'rgba(0,0,0,0)',
        plot_bgcolor = 'rgba(0,0,0,0)'
      )
  }
}

#' Generic multi-trace plot function - Returns plotly object only
createGenericMultiTracePlot <- function(traces, title = "Multi-Trace Plot", 
                                       xTitle = "", yTitle = "", height = 400,
                                       barmode = "group", orientation = "v") {
  function(df) {
    p <- plot_ly(type = if(orientation == "h") "bar" else "bar", orientation = orientation)
    
    for (trace in traces) {
      if (trace$type == "bar") {
        p <- p %>% add_trace(
          x = if(orientation == "h") trace$x else trace$y,
          y = if(orientation == "h") trace$y else trace$x,
          name = trace$name,
          marker = trace$marker,
          text = trace$text,
          hoverinfo = trace$hoverinfo
        )
      } else if (trace$type == "line") {
        p <- p %>% add_trace(
          x = trace$x,
          y = trace$y,
          name = trace$name,
          type = "scatter",
          mode = trace$mode
        )
      }
    }
    
    p %>% layout(
      title = title,
      xaxis = list(title = xTitle),
      yaxis = list(title = yTitle),
      barmode = barmode,
      paper_bgcolor = 'rgba(0,0,0,0)',
      plot_bgcolor = 'rgba(0,0,0,0)',
      showlegend = TRUE
    )
  }
}

#----------------------------------------------------------------------------------#
#------------------------- FONCTION GÉNÉRIQUE PRINCIPALE -------------------------#
#----------------------------------------------------------------------------------#

#' Create a completely generic dashboard UI that handles all cases
#' @param id The UI id
#' @param reactiveReportObject The reactive report object
#' @param appName The application name (e.g., "rf_liquidity", "ip_local", "am_fees")
#' @param user User name (optional)
#' @param tokenUI Token for UI elements (optional)
#' @param config Configuration list containing all dashboard-specific settings
createGenericDashboardUI <- function(id, reactiveReportObject, appName, user = "", tokenUI = "", config = list()) {
  ns <- NS(id)
  
  # Default configuration
  defaultConfig <- list(
    # App identification
    appName = appName,
    reportName = paste0(toupper(gsub("_", "", appName)), "_Report"),
    
    # UI elements
    showExcelDownload = TRUE,
    excelDownloadLabel = "📦 Download all in Excel",
    csvDownloadLabel = "📥 Download CSV",
    
    # Data filtering and transformation
    dataFilter = NULL,  # Function to filter data_list
    dataTransform = NULL,  # Function to transform data_list
    
    # Table configuration
    tableTypes = "DT",  # Can be "DT", "RHandsontable", or function
    showTotals = TRUE,
    totalPatterns = NULL,  # Will be determined dynamically based on data
    percentageCols = NULL,  # Will be determined dynamically based on data
    tableOptions = list(paging = FALSE, dom = 'tip', autoWidth = TRUE, ordering = TRUE),
    filterPosition = "top",
    
    # Plots configuration
    plots = list(),  # List of plot configurations
    
    # Custom controls configuration
    customControls = list(),  # List of custom control configurations
    
    # Error handling
    errorMessage = "Error.. please retry again",
    successRedirect = "#historyAnalysis"
  )
  
  # Merge with provided config
  config <- modifyList(defaultConfig, config)
  
  observe({
    req(reactiveReportObject$app)
    appSelected <- reactiveReportObject$app
    if (!tolower(gsub_underscore_dash(" ", "_", appSelected)) %in% c(config$appName)) {
      return()
    }

    showPageSpinner()
    tryCatch({
      # Cleanup previous content
      removeUI(selector = paste0("#", id, "ContentAnalysis"), immediate = TRUE)

      data_list <- reactiveReportObject$reportData
      if (is.null(data_list)) {
        hidePageSpinner()
        return()
      }
      if (!is.list(data_list)) {
        data_list <- list(data_list)
        names(data_list) <- c("Report")
      }

      # Apply data filter if provided
      if (!is.null(config$dataFilter)) {
        data_list <- config$dataFilter(data_list)
        if (length(data_list) == 0) {
          hidePageSpinner()
          runjs("toastr.error('No data found','',toastr.options.timeOut='500');")
          return()
        }
      }

      # Apply data transformation if provided
      if (!is.null(config$dataTransform)) {
        data_list <- config$dataTransform(data_list)
      }

      # Note: typesOfTable will be determined per table during rendering

      # Build tabs
      tabs <- Map(function(i) list(id = paste0(id, "-", i, "_", tokenUI), name = names(data_list)[i]), seq_len(length(data_list)))

      ui_root <- tags$div(
        id = paste0(id, "ContentAnalysis"),
        class = "row",
        if (config$showExcelDownload) {
          tags$div(class = "col-12 mb-2",
            downloadButton(ns(paste0("download_all_data_excel_", tokenUI)), config$excelDownloadLabel, class = "btn btn-primary my-2")
          )
        },
        tags$div(class = "col-12", Generate_dashboard_tabs_table(tabs))
      )

      insertUI(selector = paste0("#", id, "Content"), ui = ui_root, immediate = TRUE)

      # Populate each tab content
      for (i in seq_along(data_list)) {
        local({
          boolDfToShow <- TRUE
          idx <- i
          df <- data_list[[idx]]
          table_name <- names(data_list)[idx]
          tab_id <- paste0(id, "-", idx, "_", tokenUI)
          
          # DEBUG: Print table info
          cat("🔍 DEBUG: ===== Processing table", idx, "=====\n")
          cat("🔍 DEBUG: Table name:", table_name, "\n")
          cat("🔍 DEBUG: Tab ID:", tab_id, "\n")
          cat("🔍 DEBUG: Data dimensions:", nrow(df), "x", ncol(df), "\n")
          cat("🔍 DEBUG: Column names:", paste(names(df), collapse = ", "), "\n")
          if (nrow(df) > 0) {
            cat("🔍 DEBUG: First few rows:\n")
            print(head(df, 3))
          }

          # Add per-tab controls (download + plots container) above the DT
          insertUI(
            selector = paste0("#nav-", tab_id),
            where = "afterBegin",
            ui = tags$div(
              class = "my-3",
              fluidRow(
                column(12, class = "d-flex justify-content-between align-items-center mb-2",
                  downloadButton(outputId = paste0("download_", tab_id, "_", tokenUI), label = config$csvDownloadLabel, class = "btn btn-sm btn-success")
                )
              ),
              tags$div(id = paste0("plots_", tab_id))
            )
          )

          # Add custom controls if any
          if (length(config$customControls) > 0) {
            for (control in config$customControls) {
              if (grepl(control$pattern, gsub_underscore_dash(" ", "_", tolower(table_name)))) {
                insertUI(selector = paste0("#", paste0("plots_", tab_id)), where = "beforeEnd", ui = control$ui)
                if (!is.null(control$logic)) {
                  control$logic(df, table_name, tab_id, tokenUI)
                }
              }
            }
          }

          # Add plots based on configuration
          cat("🔍 DEBUG: Starting plot configuration check...\n")
          cat("🔍 DEBUG: Number of plot configs:", length(config$plots), "\n")
          
          if (length(config$plots) > 0) {
            for (i in seq_along(config$plots)) {
              plot_config <- config$plots[[i]]
              pattern_check <- grepl(plot_config$pattern, gsub_underscore_dash(" ", "_", tolower(table_name)))
              
              cat("🔍 DEBUG: Plot config", i, "- Pattern:", plot_config$pattern, "\n")
              cat("🔍 DEBUG: Table name (processed):", gsub_underscore_dash(" ", "_", tolower(table_name)), "\n")
              cat("🔍 DEBUG: Pattern match:", pattern_check, "\n")
              
              if (pattern_check) {
                cat("✅ DEBUG: Pattern matched! Creating UI and plots...\n")
                
                # Call UI function with parameters if it's a function, otherwise use as is
                ui_content <- if (is.function(plot_config$ui)) {
                  cat("🔍 DEBUG: UI is a function, calling with tab_id:", tab_id, "tokenUI:", tokenUI, "\n")
                  result_ui <- plot_config$ui(tab_id, tokenUI)
                  cat("🔍 DEBUG: UI function returned\n")
                  result_ui
                } else {
                  cat("🔍 DEBUG: UI is static content\n")
                  plot_config$ui
                }
                
                selector_target <- paste0("#", paste0("plots_", tab_id))
                cat("🔍 DEBUG: Inserting UI with selector:", selector_target, "\n")
                insertUI(selector = selector_target, where = "beforeEnd", ui = ui_content)
                cat("✅ DEBUG: UI inserted successfully\n")
                
                # DEBUG: Print plot configuration info
                cat("🔍 DEBUG: Plot config found for pattern:", plot_config$pattern, "\n")
                cat("🔍 DEBUG: Table name:", table_name, "\n")
                cat("🔍 DEBUG: Number of plots to create:", length(plot_config$plots), "\n")
                cat("🔍 DEBUG: Plot names:", names(plot_config$plots), "\n")
                
                # Add plot logic - Use EXACTLY the same approach as code.R
                for (plot_name in names(plot_config$plots)) {
                  plot_spec <- plot_config$plots[[plot_name]]
                  plot_output_id <- paste0(plot_name, "_", tab_id, "_", tokenUI)
                  
                  cat("🔍 DEBUG: Creating plot:", plot_name, "with ID:", plot_output_id, "\n")
                  cat("🔍 DEBUG: Data frame columns:", paste(names(df), collapse = ", "), "\n")
                  cat("🔍 DEBUG: Data frame rows:", nrow(df), "\n")
                  
                  if (is.function(plot_spec)) {
                    # Check if it's a custom function (takes 3 params) or generic function (takes 1 param)
                    plot_params <- formals(plot_spec)
                    cat("🔍 DEBUG: Function has", length(plot_params), "parameters\n")
                    
                    if (length(plot_params) >= 3) {
                      cat("🔍 DEBUG: Executing custom function for", plot_name, "\n")
                      tryCatch({
                        # Custom function - execute exactly like in code.R
                        result <- plot_spec(df, tab_id, tokenUI)
                        output[[plot_output_id]] <- result
                        cat("✅ DEBUG: Successfully assigned custom plot", plot_name, "\n")
                      }, error = function(e) {
                        cat("❌ DEBUG: Error in custom plot", plot_name, ":", e$message, "\n")
                        print(e)
                      })
                    } else {
                      cat("🔍 DEBUG: Executing generic function for", plot_name, "\n")
                      tryCatch({
                        # Generic function
                        output[[plot_output_id]] <- renderPlotly({
                          cat("🔍 DEBUG: Inside renderPlotly for", plot_name, "\n")
                          plot_result <- plot_spec(df)
                          cat("✅ DEBUG: Plot object created for", plot_name, "\n")
                          plot_result
                        })
                        cat("✅ DEBUG: Successfully assigned generic plot", plot_name, "\n")
                      }, error = function(e) {
                        cat("❌ DEBUG: Error in generic plot", plot_name, ":", e$message, "\n")
                        print(e)
                      })
                    }
                  } else if (is.list(plot_spec) && !is.null(plot_spec$renderer)) {
                    cat("🔍 DEBUG: Executing list renderer for", plot_name, "\n")
                    tryCatch({
                      output[[plot_output_id]] <- plot_spec$renderer(df, tab_id, tokenUI)
                      cat("✅ DEBUG: Successfully assigned list renderer plot", plot_name, "\n")
                    }, error = function(e) {
                      cat("❌ DEBUG: Error in list renderer", plot_name, ":", e$message, "\n")
                      print(e)
                    })
                  } else {
                    cat("🔍 DEBUG: Direct assignment for", plot_name, "\n")
                    output[[plot_output_id]] <- plot_spec
                    cat("✅ DEBUG: Successfully assigned direct plot", plot_name, "\n")
                  }
                  
                  # Verify the output was actually assigned
                  if (exists(plot_output_id, envir = as.environment(output))) {
                    cat("✅ DEBUG: Confirmed plot", plot_output_id, "exists in output\n")
                  } else {
                    cat("❌ DEBUG: Plot", plot_output_id, "NOT found in output!\n")
                  }
                }
              }
            }
          }

          # Handle special table types
          if (grepl("interface_alloc", gsub_underscore_dash(" ", "_", tolower(table_name)))) {
            boolDfToShow <- FALSE
            # This will be handled by custom controls logic
          }

          # Table rendering
          if (boolDfToShow) {
            # Determine table type dynamically
            table_type <- if (is.function(config$tableTypes)) {
              config$tableTypes(data_list, table_name, df)
            } else if (is.character(config$tableTypes) && length(config$tableTypes) == 1) {
              config$tableTypes
            } else if (is.character(config$tableTypes) && length(config$tableTypes) == length(data_list)) {
              config$tableTypes[idx]
            } else {
              "DT"  # Default fallback
            }
            
            if (table_type == "DT") {
              output[[paste0("td_dashboard_", tab_id)]] <- renderDT({
                num_cols <- names(df)[sapply(df, is.numeric)]
                df_clean <- df
                
                # Determine if totals should be shown
                show_total <- FALSE
                if (config$showTotals) {
                  if (is.null(config$totalPatterns)) {
                    # Auto-detect based on data content and table characteristics
                    has_numeric_cols <- any(sapply(df, is.numeric))
                    has_multiple_rows <- nrow(df) > 1
                    has_summary_indicators <- any(grepl("total|sum|aggregate|summary|amount|value|count", tolower(names(df))))
                    table_name_suggests_totals <- grepl("report|summary|total|aggregate|calcul|kpi|intermediate|weighted|stress", 
                                                      gsub_underscore_dash(" ", "_", tolower(table_name)))
                    
                    show_total <- has_numeric_cols && has_multiple_rows && (has_summary_indicators || table_name_suggests_totals)
                  } else if (is.function(config$totalPatterns)) {
                    show_total <- config$totalPatterns(table_name, df)
                  } else {
                    show_total <- any(sapply(config$totalPatterns, function(pattern) {
                      grepl(pattern, gsub_underscore_dash(" ", "_", tolower(table_name)))
                    }))
                  }
                }
                
                if (show_total && length(num_cols) > 0) {
                  total_row <- df_clean[, lapply(.SD, function(x) if (is.numeric(x)) sum(x, na.rm = TRUE) else NA), .SDcols = num_cols]
                  total_row[, setdiff(names(df_clean), num_cols) := lapply(setdiff(names(df_clean), num_cols), function(x) "Total")]
                  df_clean <- rbind(df_clean, total_row, fill = TRUE)
                }
                
                dt <- datatable(df_clean, rownames = FALSE, options = config$tableOptions, filter = config$filterPosition)
                
                # Determine percentage columns dynamically
                percentage_cols <- if (is.null(config$percentageCols)) {
                  # Auto-detect percentage columns based on data content and column names
                  numeric_cols <- names(df)[sapply(df, is.numeric)]
                  
                  # Check column names for percentage indicators
                  name_indicators <- grepl("weight|percent|rate|ratio|pct|share|allocation|distribution", tolower(numeric_cols))
                  
                  # Check data content for percentage-like values (0-1 range or 0-100 range)
                  content_indicators <- sapply(numeric_cols, function(col) {
                    values <- df[[col]]
                    if (length(values) == 0) return(FALSE)
                    # Check if values are in percentage range (0-1 or 0-100)
                    all_values <- values[!is.na(values)]
                    if (length(all_values) == 0) return(FALSE)
                    max_val <- max(all_values, na.rm = TRUE)
                    min_val <- min(all_values, na.rm = TRUE)
                    # Values between 0-1 or 0-100 with reasonable distribution
                    (max_val <= 1.1 && min_val >= -0.1) || (max_val <= 110 && min_val >= -10 && max_val > 1)
                  })
                  
                  # Combine name and content indicators
                  numeric_cols[name_indicators | content_indicators]
                } else if (is.function(config$percentageCols)) {
                  config$percentageCols(df)
                } else {
                  config$percentageCols
                }
                
                for (col in num_cols) {
                  if (col %in% percentage_cols) {
                    dt <- DT::formatPercentage(dt, columns = col, digits = 2)
                  } else {
                    dt <- DT::formatCurrency(dt, columns = col, currency = "", digits = 0, interval = 3, mark = " ")
                  }
                }
                
                if (show_total) {
                  dt <- DT::formatStyle(dt, columns = 0, target = "row", rows = nrow(df_clean), fontWeight = "bold", backgroundColor = "#f9f9f9")
                }
                
                dt
              })
            } else if (table_type == "RHandsontable") {
              output[[paste0("td_dashboard_", tab_id)]] <- renderRHandsontable({
                rhandsontable(df, readOnly = FALSE, width = "100%", height = 400) %>%
                  hot_cols(columnSorting = TRUE) %>%
                  hot_context_menu(allowRowEdit = TRUE, allowColEdit = TRUE)
              })
            }
          }

          # Downloads
          output[[paste0("download_", tab_id, "_", tokenUI)]] <- downloadHandler(
            filename = function() paste0(gsub("[\\/:*?\"<>|]", "_", table_name), ".csv"),
            content = function(file) {
              fwrite(df, file, row.names = FALSE, sep = user_separator(), quote = TRUE)
            }
          )
        })
      }

      # Download all to Excel
      if (config$showExcelDownload) {
        output[[ns(paste0("download_all_data_excel_", tokenUI))]] <- downloadHandler(
          filename = function() paste0(config$reportName, "_", Sys.Date(), ".xlsx"),
          content = function(file) {
            openxlsx::write.xlsx(data_list, file)
          }
        )
      }

      hidePageSpinner()
      runjs(paste0("$('a[href=\"", config$successRedirect, "\"]').click();"))
    }, error = function(e) {
      print(e)
      hidePageSpinner()
      runjs(paste0("toastr.error('", config$errorMessage, "','',toastr.options.timeOut='500');"))
    })
  })
}

#----------------------------------------------------------------------------------#
#------------------------- FONCTIONS SPÉCIALISÉES --------------------------------#
#----------------------------------------------------------------------------------#

#' Create RFLiquidity UI using the generic function
createRFLiquidityUI <- function(id, reactiveReportObject, user = "", tokenUI = "") {
  config <- list(
    appName = "rf_liquidity",
    reportName = "RiskFrameworkLiquidity_Report",
    tableTypes = "DT",  # Toutes les tables sont des DataTables
    totalPatterns = c("intermediate_report", "weighted", "stress_impact"),  # Patterns spécifiques pour RF Liquidity
    percentageCols = c("lrm_weight", "Impact Weighted Resource"),  # Colonnes de pourcentage spécifiques
    plots = list(
      # Intermediate report plots
      list(
        pattern = "intermediate_report",
        ui = function(tab_id, tokenUI) {
          fluidRow(
            column(12, class = "col-12 col-md-4", plotlyOutput(outputId = paste0("plot_impact_", tab_id, "_", tokenUI), height = "550px")),
            column(12, class = "col-12 col-md-4", plotlyOutput(outputId = paste0("plot_waterfall_", tab_id, "_", tokenUI), height = "550px")),
            column(12, class = "col-12 col-md-4", plotlyOutput(outputId = paste0("plot_pie_", tab_id, "_", tokenUI), height = "550px"))
          )
        },
        plots = list(
          plot_impact = function(df, tab_id, tokenUI) {
            renderPlotly({
              req(df$lrm_classification, df$Ressources_before_haircut)
              plot_ly(df,
                x = ~lrm_classification,
                y = ~Ressources_before_haircut,
                type = "bar",
                text = ~scales::percent(Ressources_before_haircut, accuracy = 0.1),
                hoverinfo = "text+y",
                color = ~lrm_classification
              ) %>%
              layout(title = "Resources before haircut", xaxis = list(title = ""), yaxis = list(title = "Impact (%)")) %>%
              layout(paper_bgcolor = 'rgba(0,0,0,0)', plot_bgcolor = 'rgba(0,0,0,0)')
            })
          },
          plot_waterfall = function(df, tab_id, tokenUI) {
            renderPlotly({
              req(df$lrm_classification, df$Financial_Impact)
              df_agg <- df %>%
                dplyr::group_by(lrm_classification) %>%
                dplyr::summarise(Financial_Impact = sum(-Financial_Impact, na.rm = TRUE)) %>%
                dplyr::arrange(desc(abs(Financial_Impact))) %>%
                dplyr::mutate(
                  prefix = paste0(LETTERS[seq_along(lrm_classification)], ". "),
                  label = paste0(prefix, lrm_classification),
                  measure = "relative",
                  text = format(Financial_Impact, big.mark = " ")
                )
              total <- data.frame(
                label = "Total",
                Financial_Impact = sum(df_agg$Financial_Impact, na.rm = TRUE),
                measure = "total",
                text = format(sum(df_agg$Financial_Impact, na.rm = TRUE), big.mark = " ")
              )
              df_waterfall <- dplyr::bind_rows(df_agg[, c("label", "Financial_Impact", "measure", "text")], total)
              plot_ly(
                df_waterfall,
                type = "waterfall",
                x = ~label,
                y = ~Financial_Impact,
                text = ~text,
                measure = ~measure,
                textposition = "outside",
                connector = list(line = list(color = "rgba(63, 63, 63, 0.7)"))
              ) %>%
                layout(
                  title = "Financial Impact",
                  xaxis = list(title = "", tickangle = -45),
                  yaxis = list(title = "Financial Impact (€)"),
                  paper_bgcolor = 'rgba(0,0,0,0)',
                  plot_bgcolor = 'rgba(0,0,0,0)'
                )
            })
          },
          plot_pie = function(df, tab_id, tokenUI) {
            renderPlotly({
              req(df$lrm_classification, df$Weighted_resources_after_encumbrance)
              plot_ly(
                df,
                labels = ~lrm_classification,
                values = ~abs(Weighted_resources_after_encumbrance),
                type = "pie",
                textinfo = "label+percent",
                hoverinfo = "label+value+percent"
              ) %>%
                layout(title = "Weighted Resources After Encumbrance", showlegend = TRUE) %>%
                layout(paper_bgcolor = 'rgba(0,0,0,0)', plot_bgcolor = 'rgba(0,0,0,0)')
            })
          }
        )
      ),
      # Stress impact report plots
      list(
        pattern = "stress_impact_report",
        ui = function(tab_id, tokenUI) {
          fluidRow(
            column(12, class = "col-12 col-md-4 offset-md-4", plotlyOutput(outputId = paste0("plot_pie_", tab_id, "_", tokenUI), height = "550px"))
          )
        },
        plots = list(
          plot_pie = function(df, tab_id, tokenUI) {
            renderPlotly({
              req(df$risk_module, df$external_figures)
              plot_ly(
                df,
                labels = ~risk_module,
                values = ~abs(external_figures),
                type = "pie",
                textinfo = "label+percent",
                hoverinfo = "label+value+percent"
              ) %>%
                layout(title = "External Figures", showlegend = TRUE) %>%
                layout(paper_bgcolor = 'rgba(0,0,0,0)', plot_bgcolor = 'rgba(0,0,0,0)')
            })
          }
        )
      ),
      # Liquidity report plots
      list(
        pattern = "liquidity_report",
        ui = function(tab_id, tokenUI) {
          fluidRow(
            column(12, plotlyOutput(outputId = paste0("plot_liquidity_", tab_id, "_", tokenUI), height = "200px"))
          )
        },
        plots = list(
          plot_liquidity = function(df, tab_id, tokenUI) {
            renderPlotly({
              df_vals <- df %>%
                dplyr::filter(get(names(df)[1]) %in% c("Excess liquidity", "Stress impact", "Available weighted resources")) %>%
                tidyr::pivot_wider(names_from = names(df)[1], values_from = `New methodology`) %>%
                dplyr::mutate(stress = `Stress impact`, excess = `Excess liquidity`)
              
              traces <- list(
                list(
                  type = "bar",
                  x = df_vals$`Stress impact`,
                  y = "Available weighted resources",
                  name = "Stress impact",
                  marker = list(color = 'rgba(255, 99, 71, 0.8)'),
                  text = format(df_vals$`Stress impact`, big.mark = " "),
                  hoverinfo = "text+x"
                ),
                list(
                  type = "bar",
                  x = df_vals$`Excess liquidity`,
                  y = "Available weighted resources",
                  name = "Excess liquidity",
                  marker = list(color = 'rgba(0, 200, 0, 0.7)'),
                  text = format(df_vals$`Excess liquidity`, big.mark = " "),
                  hoverinfo = "text+x"
                )
              )
              
              createGenericMultiTracePlot(
                traces = traces,
                title = "",
                xTitle = "Amount (mEUR)",
                yTitle = "",
                height = 200,
                barmode = "stack",
                orientation = "h"
              )(df, tab_id, tokenUI)
            })
          }
        )
      )
    )
  )
  
  createGenericDashboardUI(id, reactiveReportObject, "rf_liquidity", user, tokenUI, config)
}

#' Create IPLocalMain UI using the generic function
createIPLocalMainUI <- function(id, reactiveReportObject, user = "", tokenUI = "") {
  config <- list(
    appName = "ip_local",
    reportName = "IPLocalMain_Report",
    csvDownloadLabel = "📥 Download all the file in CSV",
    dataFilter = function(data_list) {
      # Ne garder dans data_list que les éléments dont le nom contient "interface"
      data_list[grepl("interface", gsub_underscore_dash(" ", "_", tolower(names(data_list))))]
    },
    tableTypes = function(data_list, table_name, df) {
      # Utiliser RHandsontable pour les tables d'allocation, DT pour les autres
      if (grepl("interface_alloc", gsub_underscore_dash(" ", "_", tolower(table_name)))) {
        "RHandsontable"
      } else {
        "DT"
      }
    },
    totalPatterns = c("intermediate_report", "weighted", "stress_impact"),  # Patterns pour les totaux
    percentageCols = c("lrm_weight", "Impact Weighted Resource"),  # Colonnes de pourcentage
    customControls = list(
      list(
        pattern = "interface_alloc",
        ui = fluidRow(
          column(12, class = "col-12 col-md-4", customSelectWithValues(inputId = "selector_portfolios_alloc", label = "Select a portfolio", icon = "briefcase", message = "Select a portfolio", options = NULL, labels = NULL, multiple = FALSE, disabled = FALSE, selected = NULL)),
          column(12, class = "col-12 col-md-4", customSelectWithValues(inputId = "selector_source_type_alloc", label = "Select a source type", icon = "briefcase", message = "Select a source type", options = NULL, labels = NULL, multiple = FALSE, disabled = FALSE, selected = NULL)),
          column(12, class = "col-12 col-md-4", actionButton(inputId = "action_button_alloc", label = "Generate", class = "btn btn-sm btn-success btn-rounded foundation-btn-primary"))
        ),
        logic = function(df, table_name, tab_id, tokenUI) {
          portefeuilles <- unique(df$portefeuille)
          source_types <- unique(df$source_type)
          
          # Update selectors with actual data
          updateCustomSelectWithValues(session, "selector_portfolios_alloc", options = portefeuilles, labels = portefeuilles)
          updateCustomSelectWithValues(session, "selector_source_type_alloc", options = source_types, labels = source_types)
          
          observeEvent(input$action_button_alloc, {
            req(input$selector_portfolios_alloc, input$selector_source_type_alloc)
            df <- as.data.table(df)
            df_filtered <- df[portefeuille == input$selector_portfolios_alloc & source_type == input$selector_source_type_alloc,]
            df_filtered$portefeuille <- NULL
            df_filtered$source_type <- NULL
            
            value_vars <- setdiff(names(df_filtered), c("portefeuille", "source_type", "year", "SAA Asset Class", "Level 4", "Currency"))
            
            casted_list <- lapply(value_vars, function(vv) {
              dcast(df_filtered, formula = as.formula(paste("`SAA Asset Class` + `Level 4` + Currency ~ year")),
                    value.var = vv, fun.aggregate = function(x) {
                      if (length(x) == 0) NA else if (all(is.na(x))) NA else if (is.numeric(x)) sum(x, na.rm = TRUE) else {
                        x_no_na <- x[!is.na(x)]
                        if (length(x_no_na) == 0) NA else x_no_na[1]
                      }
                    })
            })
            
            names(casted_list) <- value_vars
            
            for (i in seq_along(casted_list)) {
              year_cols <- grep("^[0-9]{4}$", names(casted_list[[i]]), value = TRUE)
              new_names <- paste0(value_vars[i], "_", year_cols)
              setnames(casted_list[[i]], year_cols, new_names)
            }
            
            df_final <- Reduce(function(x, y) merge(x, y, by = c("SAA Asset Class", "Level 4", "Currency"), all = TRUE), casted_list)
            
            output[[paste0("td_dashboard_", tab_id)]] <- renderRHandsontable({
              rhandsontable(df_final, readOnly = FALSE, width = "100%", height = 400) %>%
                hot_cols(columnSorting = TRUE) %>%
                hot_context_menu(allowRowEdit = TRUE, allowColEdit = TRUE)
            })
          })
        }
      )
    )
  )
  
  createGenericDashboardUI(id, reactiveReportObject, "ip_local", user, tokenUI, config)
}

#' Create AMFees UI using the generic function
createAMFeesUI <- function(id, reactiveReportObject, user = "", tokenUI = "") {
  config <- list(
    appName = "am_fees",
    reportName = "AMFees_Report",
    tableTypes = "DT",  # Toutes les tables sont des DataTables
    totalPatterns = c("calcul_report", "kpi_axa_im_report"),  # Patterns spécifiques pour AM Fees
    percentageCols = c("lrm_weight", "Impact Weighted Resource")  # Colonnes de pourcentage
  )
  
  createGenericDashboardUI(id, reactiveReportObject, "am_fees", user, tokenUI, config)
}

#----------------------------------------------------------------------------------#
#------------------------- FONCTION DE LANCEMENT --------------------------------#
#----------------------------------------------------------------------------------#

launch_dashboard_server <- function(appSelected, reactiveReportObject, type = "currentRun") {
  if(gsub_underscore_dash(" ", "_", tolower(appSelected)) %in% c("ip_local")) {
    createIPLocalMainUI(type, reactiveReportObject, user = isolate(user_email()), tokenUI = generate_token(5))
  }
  if(gsub_underscore_dash(" ", "_", tolower(appSelected)) %in% c("rf_liquidity")) {
    createRFLiquidityUI(type, reactiveReportObject, user = isolate(user_email()), tokenUI = generate_token(5))
  }
  if(gsub_underscore_dash(" ", "_", tolower(appSelected)) %in% c("am_fees")) {
    createAMFeesUI(type, reactiveReportObject, user = isolate(user_email()), tokenUI = generate_token(5))
  }
}



🔍 DEBUG: Starting plot configuration check...
🔍 DEBUG: Number of plot configs: 0 
🔍 DEBUG: ===== Processing table 3 =====
🔍 DEBUG: Table name: PnL Weighted 
🔍 DEBUG: Tab ID: currentRun-3_kBLVD 
🔍 DEBUG: Data dimensions: 131 x 5 
🔍 DEBUG: Column names: codename, PnL, lrm_classification, lrm_weight, Weighted PnL 
🔍 DEBUG: First few rows:
                                                      codename             PnL
                                                        <char>           <num>
1: AWA3-Corporate bonds-Floating Rate Note-crv_EUR_AA_FIN-ISIN        0.576024
2:     AWA3-Corporate bonds-Fixed Rate Bond-crv_USD_A_FIN-ISIN -1294287.408185
3:     AWA3-Corporate bonds-Fixed Rate Bond-crv_EUR_A_IND-ISIN -6735251.654724
   lrm_classification lrm_weight    Weighted PnL
               <char>      <num>           <num>
1: Corporate bonds IG       0.94        0.541462
2: Corporate bonds IG       0.94 -1216630.163694
3: Corporate bonds IG       0.94 -6331136.555441
