#----------------------------------------------------------------------------------#
#------------------------- SOLUTION GÉNÉRIQUE COMPLÈTEMENT FACTORISÉE ------------#
#----------------------------------------------------------------------------------#

#----------------------------------------------------------------------------------#
#------------------------- FONCTION GÉNÉRIQUE DE TRAITEMENT DE DONNÉES -----------#
#----------------------------------------------------------------------------------#

#' Generic function to process dashboard data
process_dashboard_data <- function(params, appName, excludePattern = NULL) {
  appSelected <- params$runInfo$appSelected
  run_date <- params$runInfo$runDate
  environment <- params$environment

  engine_output <- fread(path_admin_param_engine_output, sep = global_separator)
  tempOutput <- engine_output[tolower(gsub_underscore_dash(" ", "_", engine_output$app)) == tolower(gsub_underscore_dash(" ", "_", appSelected)),]
  files <- tempOutput[tolower(tempOutput$type) == "file", ]
  files$tableaddress <- sprintf(as.character(files$tableaddress), run_date)
  if (!is.null(excludePattern)) {
    files <- files[!grepl(excludePattern, tolower(files$output)), ]
  }

  prod_path <- paste0(foundationRuns_dbfs_root_path, "/", gsub_underscore_dash(" ", "_", tolower(appSelected)), "/", environment, "/Outputs/", run_date)
  data <- list()
  j <- 1
  for(i in 1:nrow(files)){
    file_path <- file.path(prod_path, files$tableaddress[i])
    if(grepl(".csv", file_path)){
      data[[j]] <- fread(file_path, sep = global_separator)
      names(data)[j] <- files$output[i]
    }
    j <- j + 1
  }
  return(data)
}

# Wrapper functions for backward compatibility
process_dashboard_risk_framework_liquidity <- function(params) {
  process_dashboard_data(params, "rf_liquidity", "awa")
}

process_dashboard_ip_local_main <- function(params) {
  process_dashboard_data(params, "ip_local", "awa")
}

process_dashboard_am_fees_report <- function(params) {
  process_dashboard_data(params, "am_fees")
}

#----------------------------------------------------------------------------------#
#------------------------- FONCTIONS GÉNÉRIQUES DE PLOTS -------------------------#
#----------------------------------------------------------------------------------#

#' Fonction générique pour créer des plots intelligents basés sur les données
#' @param df Data frame à analyser
#' @param plot_type Type de plot ("bar", "pie", "scatter", "histogram", "box", "auto")
#' @param x_col Colonne pour l'axe X
#' @param y_col Colonne pour l'axe Y
#' @param color_col Colonne pour le regroupement/couleur
#' @param title Titre du graphique
#' @return Objet plotly
createGenericPlot <- function(df, plot_type = "auto", x_col = NULL, y_col = NULL, 
                              color_col = NULL, title = NULL) {
  
  # Auto-détection des colonnes si non spécifiées
  if (is.null(color_col) && "lrm_classification" %in% names(df)) {
    color_col <- "lrm_classification"
  }
  
  numeric_cols <- names(df)[sapply(df, is.numeric)]
  
  if (is.null(y_col) && length(numeric_cols) > 0) {
    y_col <- numeric_cols[1]
  }
  
  if (is.null(x_col)) {
    x_col <- color_col
  }
  
  # Auto-détection du type de plot
  if (plot_type == "auto") {
    if (!is.null(color_col) && !is.null(y_col)) {
      plot_type <- "bar"
    } else if (length(numeric_cols) > 0) {
      plot_type <- "histogram"
    } else {
      plot_type <- "bar"
    }
  }
  
  # Titre automatique si non spécifié
  if (is.null(title)) {
    title <- paste(tools::toTitleCase(plot_type), "Plot")
    if (!is.null(y_col)) title <- paste(title, "of", y_col)
  }
  
  # Création du plot selon le type
  switch(plot_type,
    "bar" = create_bar_plot(df, x_col, y_col, color_col, title),
    "pie" = create_pie_plot(df, x_col, y_col, title),
    "scatter" = create_scatter_plot(df, x_col, y_col, color_col, title),
    "histogram" = create_histogram_plot(df, y_col, title),
    "box" = create_box_plot(df, x_col, y_col, title),
    "waterfall" = create_waterfall_plot(df, x_col, y_col, title),
    create_bar_plot(df, x_col, y_col, color_col, title)  # fallback
  )
}

# Fonctions spécialisées pour chaque type de plot
create_bar_plot <- function(df, x_col, y_col, color_col, title) {
  # Validation des données (remplace req() pour utilisation hors Shiny)
  if (is.null(df[[x_col]]) || is.null(df[[y_col]])) {
    return(plot_ly() %>% layout(title = "Missing data"))
  }
  
  # Agréger les données si nécessaire
  if (!is.null(color_col) && color_col %in% names(df)) {
    df_plot <- df %>%
      dplyr::group_by(!!sym(x_col)) %>%
      dplyr::summarise(total = sum(!!sym(y_col), na.rm = TRUE), .groups = 'drop') %>%
      dplyr::arrange(desc(abs(total)))
  } else {
    df_plot <- df
    names(df_plot)[names(df_plot) == y_col] <- "total"
  }
  
  plot_ly(df_plot,
    x = ~get(x_col),
    y = ~total,
    type = "bar",
    text = ~format(total, big.mark = " ", scientific = FALSE),
    textposition = "outside",
    marker = list(color = 'steelblue')
  ) %>%
  layout(
    title = title,
    xaxis = list(title = x_col, tickangle = -45),
    yaxis = list(title = y_col),
    paper_bgcolor = 'rgba(0,0,0,0)',
    plot_bgcolor = 'rgba(0,0,0,0)'
  )
}

create_pie_plot <- function(df, x_col, y_col, title) {
  if (is.null(df[[x_col]]) || is.null(df[[y_col]])) {
    return(plot_ly() %>% layout(title = "Missing data"))
  }
  
  df_pie <- df %>%
    dplyr::group_by(!!sym(x_col)) %>%
    dplyr::summarise(total = sum(abs(!!sym(y_col)), na.rm = TRUE), .groups = 'drop') %>%
    dplyr::filter(total > 0)
  
  plot_ly(df_pie,
    labels = ~get(x_col),
    values = ~total,
    type = "pie",
    textinfo = "label+percent",
    hoverinfo = "label+value+percent"
  ) %>%
  layout(
    title = title,
    showlegend = TRUE,
    paper_bgcolor = 'rgba(0,0,0,0)',
    plot_bgcolor = 'rgba(0,0,0,0)'
  )
}

create_scatter_plot <- function(df, x_col, y_col, color_col, title) {
  if (is.null(df[[x_col]]) || is.null(df[[y_col]])) {
    return(plot_ly() %>% layout(title = "Missing data"))
  }
  
  p <- plot_ly(df,
    x = ~get(x_col),
    y = ~get(y_col),
    type = "scatter",
    mode = "markers"
  )
  
  if (!is.null(color_col) && color_col %in% names(df)) {
    p <- p %>% add_trace(color = ~get(color_col))
  }
  
  p %>% layout(
    title = title,
    xaxis = list(title = x_col),
    yaxis = list(title = y_col),
    paper_bgcolor = 'rgba(0,0,0,0)',
    plot_bgcolor = 'rgba(0,0,0,0)'
  )
}

create_histogram_plot <- function(df, y_col, title) {
  if (is.null(df[[y_col]])) {
    return(plot_ly() %>% layout(title = "Missing data"))
  }
  
  plot_ly(df, x = ~get(y_col), type = "histogram") %>%
    layout(
      title = title,
      xaxis = list(title = y_col),
      yaxis = list(title = "Count"),
      paper_bgcolor = 'rgba(0,0,0,0)',
      plot_bgcolor = 'rgba(0,0,0,0)'
    )
}

create_box_plot <- function(df, x_col, y_col, title) {
  if (is.null(df[[y_col]])) {
    return(plot_ly() %>% layout(title = "Missing data"))
  }
  
  if (!is.null(x_col) && x_col %in% names(df)) {
    plot_ly(df,
      x = ~get(x_col),
      y = ~get(y_col),
      type = "box"
    )
  } else {
    plot_ly(df, y = ~get(y_col), type = "box")
  } %>%
  layout(
    title = title,
    xaxis = list(title = if(is.null(x_col)) "" else x_col),
    yaxis = list(title = y_col),
    paper_bgcolor = 'rgba(0,0,0,0)',
    plot_bgcolor = 'rgba(0,0,0,0)'
  )
}

create_waterfall_plot <- function(df, x_col, y_col, title) {
  if (is.null(df[[x_col]]) || is.null(df[[y_col]])) {
    return(plot_ly() %>% layout(title = "Missing data"))
  }
  
  df_agg <- df %>%
    dplyr::group_by(!!sym(x_col)) %>%
    dplyr::summarise(Value = sum(!!sym(y_col), na.rm = TRUE)) %>%
    dplyr::arrange(desc(abs(Value))) %>%
    dplyr::mutate(
      prefix = paste0(LETTERS[seq_along(!!sym(x_col))], ". "),
      label = paste0(prefix, !!sym(x_col)),
      measure = "relative",
      text = format(Value, big.mark = " ", scientific = FALSE)
    )
  
  total <- data.frame(
    label = "Total",
    Value = sum(df_agg$Value, na.rm = TRUE),
    measure = "total",
    text = format(sum(df_agg$Value, na.rm = TRUE), big.mark = " ", scientific = FALSE)
  )
  
  df_waterfall <- dplyr::bind_rows(df_agg[, c("label", "Value", "measure", "text")], total)
  
  plot_ly(df_waterfall,
    type = "waterfall",
    x = ~label,
    y = ~Value,
    text = ~text,
    measure = ~measure,
    textposition = "outside",
    connector = list(line = list(color = "rgba(63, 63, 63, 0.7)"))
  ) %>%
  layout(
    title = title,
    xaxis = list(title = "", tickangle = -45),
    yaxis = list(title = y_col),
    paper_bgcolor = 'rgba(0,0,0,0)',
    plot_bgcolor = 'rgba(0,0,0,0)'
  )
}

#' Fonction pour créer automatiquement des plots basés sur l'analyse des données
#' @param df Data frame
#' @param max_plots Nombre maximum de plots à créer
#' @return Liste des objets plotly
createIntelligentPlots <- function(df, max_plots = 3) {
  plots <- list()
  
  # Analyser les données
  has_classification <- "lrm_classification" %in% names(df)
  numeric_cols <- names(df)[sapply(df, is.numeric)]
  
  if (has_classification && length(numeric_cols) > 0) {
    # Plot 1: Bar chart
    plots$bar <- createGenericPlot(df, "bar", "lrm_classification", numeric_cols[1], 
                                   title = paste("Total", numeric_cols[1], "by Classification"))
    
    # Plot 2: Pie chart
    plots$pie <- createGenericPlot(df, "pie", "lrm_classification", numeric_cols[1],
                                   title = paste("Distribution of", numeric_cols[1]))
    
    # Plot 3: Scatter ou histogram selon les colonnes disponibles
    if (length(numeric_cols) >= 2) {
      plots$scatter <- createGenericPlot(df, "scatter", numeric_cols[1], numeric_cols[2], "lrm_classification",
                                         title = paste(numeric_cols[1], "vs", numeric_cols[2]))
    } else {
      plots$histogram <- createGenericPlot(df, "histogram", y_col = numeric_cols[1],
                                           title = paste("Distribution of", numeric_cols[1]))
    }
  } else if (length(numeric_cols) > 0) {
    # Sans classification, plots simples
    plots$box <- createGenericPlot(df, "box", y_col = numeric_cols[1],
                                   title = paste("Box Plot of", numeric_cols[1]))
    
    if (length(numeric_cols) >= 2) {
      plots$scatter <- createGenericPlot(df, "scatter", numeric_cols[1], numeric_cols[2],
                                         title = paste(numeric_cols[1], "vs", numeric_cols[2]))
    }
  }
  
  return(plots[1:min(length(plots), max_plots)])
}


#----------------------------------------------------------------------------------#
#------------------------- FONCTION GÉNÉRIQUE PRINCIPALE -------------------------#
#----------------------------------------------------------------------------------#

#' Create a completely generic dashboard UI that handles all cases
#' @param id The UI id
#' @param reactiveReportObject The reactive report object
#' @param appName The application name (e.g., "rf_liquidity", "ip_local", "am_fees")
#' @param user User name (optional)
#' @param tokenUI Token for UI elements (optional)
#' @param config Configuration list containing all dashboard-specific settings
createGenericDashboardUI <- function(id, reactiveReportObject, appName, user = "", tokenUI = "", config = list()) {
  ns <- NS(id)
  
  # Default configuration
  defaultConfig <- list(
    # App identification
    appName = appName,
    reportName = paste0(toupper(gsub("_", "", appName)), "_Report"),
    
    # UI elements
    showExcelDownload = TRUE,
    excelDownloadLabel = "📦 Download all in Excel",
    csvDownloadLabel = "📥 Download CSV",
    
    # Data filtering and transformation
    dataFilter = NULL,  # Function to filter data_list
    dataTransform = NULL,  # Function to transform data_list
    
    # Table configuration
    tableTypes = "DT",  # Can be "DT", "RHandsontable", or function
    showTotals = TRUE,
    totalPatterns = NULL,  # Will be determined dynamically based on data
    percentageCols = NULL,  # Will be determined dynamically based on data
    tableOptions = list(paging = FALSE, dom = 'tip', autoWidth = TRUE, ordering = TRUE),
    filterPosition = "top",
    
    # Plots configuration
    plots = list(),  # List of plot configurations
    
    # Custom controls configuration
    customControls = list(),  # List of custom control configurations
    
    # Error handling
    errorMessage = "Error.. please retry again",
    successRedirect = "#historyAnalysis"
  )
  
  # Merge with provided config
  config <- modifyList(defaultConfig, config)
  
  observe({
    req(reactiveReportObject$app)
    appSelected <- reactiveReportObject$app
    if (!tolower(gsub_underscore_dash(" ", "_", appSelected)) %in% c(config$appName)) {
      return()
    }

    showPageSpinner()
    tryCatch({
      # Cleanup previous content
      removeUI(selector = paste0("#", id, "ContentAnalysis"), immediate = TRUE)

      data_list <- reactiveReportObject$reportData
      if (is.null(data_list)) {
        hidePageSpinner()
        return()
      }
      if (!is.list(data_list)) {
        data_list <- list(data_list)
        names(data_list) <- c("Report")
      }

      # Apply data filter if provided
      if (!is.null(config$dataFilter)) {
        data_list <- config$dataFilter(data_list)
        if (length(data_list) == 0) {
          hidePageSpinner()
          runjs("toastr.error('No data found','',toastr.options.timeOut='500');")
          return()
        }
      }

      # Apply data transformation if provided
      if (!is.null(config$dataTransform)) {
        data_list <- config$dataTransform(data_list)
      }

      # Note: typesOfTable will be determined per table during rendering

      # Build tabs
      tabs <- Map(function(i) list(id = paste0(id, "-", i, "_", tokenUI), name = names(data_list)[i]), seq_len(length(data_list)))

      ui_root <- tags$div(
        id = paste0(id, "ContentAnalysis"),
        class = "row",
        if (config$showExcelDownload) {
          tags$div(class = "col-12 mb-2",
            downloadButton(ns(paste0("download_all_data_excel_", tokenUI)), config$excelDownloadLabel, class = "btn btn-primary my-2")
          )
        },
        tags$div(class = "col-12", Generate_dashboard_tabs_table(tabs))
      )

      insertUI(selector = paste0("#", id, "Content"), ui = ui_root, immediate = TRUE)

      # Populate each tab content
      for (i in seq_along(data_list)) {
        local({
          boolDfToShow <- TRUE
          idx <- i
          df <- data_list[[idx]]
          table_name <- names(data_list)[idx]
          tab_id <- paste0(id, "-", idx, "_", tokenUI)
          
          # DEBUG: Print table info
          cat("🔍 DEBUG: ===== Processing table", idx, "=====\n")
          cat("🔍 DEBUG: Table name:", table_name, "\n")
          cat("🔍 DEBUG: Tab ID:", tab_id, "\n")
          cat("🔍 DEBUG: Data dimensions:", nrow(df), "x", ncol(df), "\n")
          cat("🔍 DEBUG: Column names:", paste(names(df), collapse = ", "), "\n")
          if (nrow(df) > 0) {
            cat("🔍 DEBUG: First few rows:\n")
            print(head(df, 3))
          }

          # Add per-tab controls (download + plots container) above the DT
          insertUI(
            selector = paste0("#nav-", tab_id),
            where = "afterBegin",
            ui = tags$div(
              class = "my-3",
              fluidRow(
                column(12, class = "d-flex justify-content-between align-items-center mb-2",
                  downloadButton(outputId = paste0("download_", tab_id, "_", tokenUI), label = config$csvDownloadLabel, class = "btn btn-sm btn-success")
                )
              ),
              tags$div(id = paste0("plots_", tab_id))
            )
          )

          # Add custom controls if any
          if (length(config$customControls) > 0) {
            for (control in config$customControls) {
              if (grepl(control$pattern, gsub_underscore_dash(" ", "_", tolower(table_name)))) {
                insertUI(selector = paste0("#", paste0("plots_", tab_id)), where = "beforeEnd", ui = control$ui)
                if (!is.null(control$logic)) {
                  control$logic(df, table_name, tab_id, tokenUI)
                }
              }
            }
          }

          # APPROCHE INTERACTIVE: L'utilisateur choisit ses graphiques
          cat("🔍 DASHBOARD: Setting up interactive plot selection...\n")
          
          # Créer le bouton pour ouvrir la modale
          insertUI(
            selector = paste0("#plots_", tab_id),
            where = "beforeEnd",
            ui = tags$div(
              style = "margin: 15px 0;",
              actionButton(
                inputId = paste0("openPlotModal_", tab_id, "_", tokenUI),
                label = "📊 Créer un graphique",
                class = "btn-primary",
                style = "margin-bottom: 20px;"
              ),
              # Container pour les graphiques
              div(id = paste0("plotContainer_", tab_id, "_", tokenUI))
            )
          )
          
          # Créer la modale de configuration
          observeEvent(input[[paste0("openPlotModal_", tab_id, "_", tokenUI)]], {
            # Obtenir les colonnes disponibles
            numeric_cols <- names(df)[sapply(df, is.numeric)]
            categorical_cols <- names(df)[sapply(df, function(x) is.character(x) || is.factor(x))]
            
            showModal(modalDialog(
              title = "Configuration du graphique",
              
              # Type de graphique
              selectInput(
                paste0("plotType_", tab_id, "_", tokenUI),
                "Type de graphique:",
                choices = c(
                  "Barres" = "bar",
                  "Camembert" = "pie",
                  "Nuage de points" = "scatter",
                  "Histogramme" = "histogram",
                  "Boîte à moustaches" = "box",
                  "Cascade" = "waterfall"
                )
              ),
              
              # Colonnes X et Y
              selectInput(
                paste0("xCol_", tab_id, "_", tokenUI),
                "Colonne X:",
                choices = c("", categorical_cols, numeric_cols)
              ),
              
              selectInput(
                paste0("yCol_", tab_id, "_", tokenUI),
                "Colonne Y:",
                choices = c("", numeric_cols)
              ),
              
              # Colonne de couleur (groupement)
              selectInput(
                paste0("colorCol_", tab_id, "_", tokenUI),
                "Colonne de groupement (optionnel):",
                choices = c("Aucun" = "", categorical_cols)
              ),
              
              # Titre du graphique
              textInput(
                paste0("plotTitle_", tab_id, "_", tokenUI),
                "Titre du graphique:",
                value = "Mon graphique"
              ),
              
              footer = tagList(
                modalButton("Annuler"),
                actionButton(
                  paste0("createPlot_", tab_id, "_", tokenUI),
                  "Créer le graphique",
                  class = "btn-primary"
                )
              ),
              size = "l"
            ))
          })
          
          # Observer pour créer le graphique
          observeEvent(input[[paste0("createPlot_", tab_id, "_", tokenUI)]], {
            # Récupérer les valeurs
            plot_type <- input[[paste0("plotType_", tab_id, "_", tokenUI)]]
            x_col <- input[[paste0("xCol_", tab_id, "_", tokenUI)]]
            y_col <- input[[paste0("yCol_", tab_id, "_", tokenUI)]]
            color_col <- input[[paste0("colorCol_", tab_id, "_", tokenUI)]]
            title <- input[[paste0("plotTitle_", tab_id, "_", tokenUI)]]
            
            if (color_col == "") color_col <- NULL
            
            # Générer un ID unique pour ce graphique
            plot_id <- paste0("plot_", plot_type, "_", tab_id, "_", tokenUI, "_", round(runif(1) * 1000))
            
            # Insérer le container pour le graphique
            insertUI(
              selector = paste0("#plotContainer_", tab_id, "_", tokenUI),
              where = "beforeEnd",
              ui = tags$div(
                style = "margin: 15px 0; position: relative;",
                # Bouton de suppression
                tags$button(
                  onclick = sprintf("Shiny.setInputValue('removePlot_%s', '%s');", tab_id, plot_id),
                  class = "btn btn-danger btn-sm",
                  style = "position: absolute; right: 10px; top: 10px; z-index: 100;",
                  "✖"
                ),
                plotlyOutput(plot_id, height = "450px")
              )
            )
            
            # Créer le graphique
            output[[plot_id]] <- renderPlotly({
              cat("🔍 DASHBOARD: Creating plot of type", plot_type, "\n")
              createGenericPlot(df, plot_type, x_col, y_col, color_col, title)
            })
            
            # Fermer la modale
            removeModal()
          })
          
          # Observer pour supprimer un graphique
          observeEvent(input[[paste0("removePlot_", tab_id)]], {
            plot_id <- input[[paste0("removePlot_", tab_id)]]
            removeUI(
              selector = sprintf("div:has(> #%s)", plot_id)
            )
          })

          # Handle special table types
          if (grepl("interface_alloc", gsub_underscore_dash(" ", "_", tolower(table_name)))) {
            boolDfToShow <- FALSE
            # This will be handled by custom controls logic
          }

          # Table rendering
          if (boolDfToShow) {
            # Determine table type dynamically
            table_type <- if (is.function(config$tableTypes)) {
              config$tableTypes(data_list, table_name, df)
            } else if (is.character(config$tableTypes) && length(config$tableTypes) == 1) {
              config$tableTypes
            } else if (is.character(config$tableTypes) && length(config$tableTypes) == length(data_list)) {
              config$tableTypes[idx]
            } else {
              "DT"  # Default fallback
            }
            
            if (table_type == "DT") {
              output[[paste0("td_dashboard_", tab_id)]] <- renderDT({
                num_cols <- names(df)[sapply(df, is.numeric)]
                df_clean <- df
                
                # Determine if totals should be shown
                show_total <- FALSE
                if (config$showTotals) {
                  if (is.null(config$totalPatterns)) {
                    # Auto-detect based on data content and table characteristics
                    has_numeric_cols <- any(sapply(df, is.numeric))
                    has_multiple_rows <- nrow(df) > 1
                    has_summary_indicators <- any(grepl("total|sum|aggregate|summary|amount|value|count", tolower(names(df))))
                    table_name_suggests_totals <- grepl("report|summary|total|aggregate|calcul|kpi|intermediate|weighted|stress", 
                                                      gsub_underscore_dash(" ", "_", tolower(table_name)))
                    
                    show_total <- has_numeric_cols && has_multiple_rows && (has_summary_indicators || table_name_suggests_totals)
                  } else if (is.function(config$totalPatterns)) {
                    show_total <- config$totalPatterns(table_name, df)
                  } else {
                    show_total <- any(sapply(config$totalPatterns, function(pattern) {
                      grepl(pattern, gsub_underscore_dash(" ", "_", tolower(table_name)))
                    }))
                  }
                }
                
                if (show_total && length(num_cols) > 0) {
                  total_row <- df_clean[, lapply(.SD, function(x) if (is.numeric(x)) sum(x, na.rm = TRUE) else NA), .SDcols = num_cols]
                  total_row[, setdiff(names(df_clean), num_cols) := lapply(setdiff(names(df_clean), num_cols), function(x) "Total")]
                  df_clean <- rbind(df_clean, total_row, fill = TRUE)
                }
                
                dt <- datatable(df_clean, rownames = FALSE, options = config$tableOptions, filter = config$filterPosition)
                
                # Determine percentage columns dynamically
                percentage_cols <- if (is.null(config$percentageCols)) {
                  # Auto-detect percentage columns based on data content and column names
                  numeric_cols <- names(df)[sapply(df, is.numeric)]
                  
                  # Check column names for percentage indicators
                  name_indicators <- grepl("weight|percent|rate|ratio|pct|share|allocation|distribution", tolower(numeric_cols))
                  
                  # Check data content for percentage-like values (0-1 range or 0-100 range)
                  content_indicators <- sapply(numeric_cols, function(col) {
                    values <- df[[col]]
                    if (length(values) == 0) return(FALSE)
                    # Check if values are in percentage range (0-1 or 0-100)
                    all_values <- values[!is.na(values)]
                    if (length(all_values) == 0) return(FALSE)
                    max_val <- max(all_values, na.rm = TRUE)
                    min_val <- min(all_values, na.rm = TRUE)
                    # Values between 0-1 or 0-100 with reasonable distribution
                    (max_val <= 1.1 && min_val >= -0.1) || (max_val <= 110 && min_val >= -10 && max_val > 1)
                  })
                  
                  # Combine name and content indicators
                  numeric_cols[name_indicators | content_indicators]
                } else if (is.function(config$percentageCols)) {
                  config$percentageCols(df)
                } else {
                  config$percentageCols
                }
                
                for (col in num_cols) {
                  if (col %in% percentage_cols) {
                    dt <- DT::formatPercentage(dt, columns = col, digits = 2)
                  } else {
                    dt <- DT::formatCurrency(dt, columns = col, currency = "", digits = 0, interval = 3, mark = " ")
                  }
                }
                
                if (show_total) {
                  dt <- DT::formatStyle(dt, columns = 0, target = "row", rows = nrow(df_clean), fontWeight = "bold", backgroundColor = "#f9f9f9")
                }
                
                dt
              })
            } else if (table_type == "RHandsontable") {
              output[[paste0("td_dashboard_", tab_id)]] <- renderRHandsontable({
                rhandsontable(df, readOnly = FALSE, width = "100%", height = 400) %>%
                  hot_cols(columnSorting = TRUE) %>%
                  hot_context_menu(allowRowEdit = TRUE, allowColEdit = TRUE)
              })
            }
          }

          # Downloads
          output[[paste0("download_", tab_id, "_", tokenUI)]] <- downloadHandler(
            filename = function() paste0(gsub("[\\/:*?\"<>|]", "_", table_name), ".csv"),
            content = function(file) {
              fwrite(df, file, row.names = FALSE, sep = user_separator(), quote = TRUE)
            }
          )
        })
      }

      # Download all to Excel
      if (config$showExcelDownload) {
        output[[ns(paste0("download_all_data_excel_", tokenUI))]] <- downloadHandler(
          filename = function() paste0(config$reportName, "_", Sys.Date(), ".xlsx"),
          content = function(file) {
            openxlsx::write.xlsx(data_list, file)
          }
        )
      }

      hidePageSpinner()
      runjs(paste0("$('a[href=\"", config$successRedirect, "\"]').click();"))
    }, error = function(e) {
      print(e)
      hidePageSpinner()
      runjs(paste0("toastr.error('", config$errorMessage, "','',toastr.options.timeOut='500');"))
    })
  })
}

#----------------------------------------------------------------------------------#
#------------------------- FONCTIONS SPÉCIALISÉES --------------------------------#
#----------------------------------------------------------------------------------#

#' Create RFLiquidity UI using the generic function
createRFLiquidityUI <- function(id, reactiveReportObject, user = "", tokenUI = "") {
  config <- list(
    appName = "rf_liquidity",
    reportName = "RiskFrameworkLiquidity_Report",
    tableTypes = "DT",  # Toutes les tables sont des DataTables
    totalPatterns = c("intermediate_report", "weighted", "stress_impact"),  # Patterns spécifiques pour RF Liquidity
    percentageCols = c("lrm_weight", "Impact Weighted Resource"),  # Colonnes de pourcentage spécifiques
    plots = list(
      # Intermediate report plots (code original)
      list(
        pattern = "intermediate_report",
        ui = function(tab_id, tokenUI) {
          fluidRow(
            column(12, class = "col-12 col-md-4", plotlyOutput(outputId = paste0("plot_impact_", tab_id, "_", tokenUI), height = "550px")),
            column(12, class = "col-12 col-md-4", plotlyOutput(outputId = paste0("plot_waterfall_", tab_id, "_", tokenUI), height = "550px")),
            column(12, class = "col-12 col-md-4", plotlyOutput(outputId = paste0("plot_pie_", tab_id, "_", tokenUI), height = "550px"))
          )
        },
        plots = list(
          plot_impact = function(df, tab_id, tokenUI) {
            renderPlotly({
              req(df$lrm_classification, df$Ressources_before_haircut)
              plot_ly(df,
                x = ~lrm_classification,
                y = ~Ressources_before_haircut,
                type = "bar",
                text = ~scales::percent(Ressources_before_haircut, accuracy = 0.1),
                hoverinfo = "text+y",
                color = ~lrm_classification
              ) %>%
              layout(title = "Resources before haircut", xaxis = list(title = ""), yaxis = list(title = "Impact (%)")) %>%
              layout(paper_bgcolor = 'rgba(0,0,0,0)', plot_bgcolor = 'rgba(0,0,0,0)')
            })
          },
          plot_waterfall = function(df, tab_id, tokenUI) {
            renderPlotly({
              req(df$lrm_classification, df$Financial_Impact)
              df_agg <- df %>%
                dplyr::group_by(lrm_classification) %>%
                dplyr::summarise(Financial_Impact = sum(-Financial_Impact, na.rm = TRUE)) %>%
                dplyr::arrange(desc(abs(Financial_Impact))) %>%
                dplyr::mutate(
                  prefix = paste0(LETTERS[seq_along(lrm_classification)], ". "),
                  label = paste0(prefix, lrm_classification),
                  measure = "relative",
                  text = format(Financial_Impact, big.mark = " ")
                )
              total <- data.frame(
                label = "Total",
                Financial_Impact = sum(df_agg$Financial_Impact, na.rm = TRUE),
                measure = "total",
                text = format(sum(df_agg$Financial_Impact, na.rm = TRUE), big.mark = " ")
              )
              df_waterfall <- dplyr::bind_rows(df_agg[, c("label", "Financial_Impact", "measure", "text")], total)
              plot_ly(
                df_waterfall,
                type = "waterfall",
                x = ~label,
                y = ~Financial_Impact,
                text = ~text,
                measure = ~measure,
                textposition = "outside",
                connector = list(line = list(color = "rgba(63, 63, 63, 0.7)"))
              ) %>%
                layout(
                  title = "Financial Impact",
                  xaxis = list(title = "", tickangle = -45),
                  yaxis = list(title = "Financial Impact (€)"),
                  paper_bgcolor = 'rgba(0,0,0,0)',
                  plot_bgcolor = 'rgba(0,0,0,0)'
                )
            })
          },
          plot_pie = function(df, tab_id, tokenUI) {
            renderPlotly({
              req(df$lrm_classification, df$Weighted_resources_after_encumbrance)
              plot_ly(
                df,
                labels = ~lrm_classification,
                values = ~abs(Weighted_resources_after_encumbrance),
                type = "pie",
                textinfo = "label+percent",
                hoverinfo = "label+value+percent"
              ) %>%
                layout(title = "Weighted Resources After Encumbrance", showlegend = TRUE) %>%
                layout(paper_bgcolor = 'rgba(0,0,0,0)', plot_bgcolor = 'rgba(0,0,0,0)')
            })
          }
        )
      ),
      # PnL tables (custom pattern for your data)
      list(
        pattern = "pnl|weighted",
        ui = function(tab_id, tokenUI) {
          fluidRow(
            column(12, class = "col-12 col-md-4", plotlyOutput(outputId = paste0("plot_pnl_bar_", tab_id, "_", tokenUI), height = "550px")),
            column(12, class = "col-12 col-md-4", plotlyOutput(outputId = paste0("plot_pnl_waterfall_", tab_id, "_", tokenUI), height = "550px")),
            column(12, class = "col-12 col-md-4", plotlyOutput(outputId = paste0("plot_pnl_pie_", tab_id, "_", tokenUI), height = "550px"))
          )
        },
        plots = list(
          plot_pnl_bar = function(df, tab_id, tokenUI) {
            renderPlotly({
              req(df$lrm_classification, df$PnL)
              plot_ly(df,
                x = ~lrm_classification,
                y = ~PnL,
                type = "bar",
                text = ~format(PnL, big.mark = " "),
                hoverinfo = "text+y",
                color = ~lrm_classification
              ) %>%
              layout(title = "PnL by Classification", xaxis = list(title = ""), yaxis = list(title = "PnL (€)")) %>%
              layout(paper_bgcolor = 'rgba(0,0,0,0)', plot_bgcolor = 'rgba(0,0,0,0)')
            })
          },
          plot_pnl_waterfall = function(df, tab_id, tokenUI) {
            renderPlotly({
              req(df$lrm_classification, df$`Weighted PnL`)
              df_agg <- df %>%
                dplyr::group_by(lrm_classification) %>%
                dplyr::summarise(Weighted_PnL = sum(`Weighted PnL`, na.rm = TRUE)) %>%
                dplyr::arrange(desc(abs(Weighted_PnL))) %>%
                dplyr::mutate(
                  prefix = paste0(LETTERS[seq_along(lrm_classification)], ". "),
                  label = paste0(prefix, lrm_classification),
                  measure = "relative",
                  text = format(Weighted_PnL, big.mark = " ")
                )
              total <- data.frame(
                label = "Total",
                Weighted_PnL = sum(df_agg$Weighted_PnL, na.rm = TRUE),
                measure = "total",
                text = format(sum(df_agg$Weighted_PnL, na.rm = TRUE), big.mark = " ")
              )
              df_waterfall <- dplyr::bind_rows(df_agg[, c("label", "Weighted_PnL", "measure", "text")], total)
              plot_ly(
                df_waterfall,
                type = "waterfall",
                x = ~label,
                y = ~Weighted_PnL,
                text = ~text,
                measure = ~measure,
                textposition = "outside",
                connector = list(line = list(color = "rgba(63, 63, 63, 0.7)"))
              ) %>%
                layout(
                  title = "Weighted PnL Impact",
                  xaxis = list(title = "", tickangle = -45),
                  yaxis = list(title = "Weighted PnL (€)"),
                  paper_bgcolor = 'rgba(0,0,0,0)',
                  plot_bgcolor = 'rgba(0,0,0,0)'
                )
            })
          },
          plot_pnl_pie = function(df, tab_id, tokenUI) {
            renderPlotly({
              req(df$lrm_classification, df$`Weighted PnL`)
              df_pie <- df %>%
                dplyr::group_by(lrm_classification) %>%
                dplyr::summarise(weighted_pnl_abs = sum(abs(`Weighted PnL`), na.rm = TRUE), .groups = 'drop')
              plot_ly(
                df_pie,
                labels = ~lrm_classification,
                values = ~weighted_pnl_abs,
                type = "pie",
                textinfo = "label+percent",
                hoverinfo = "label+value+percent"
              ) %>%
                layout(title = "Weighted PnL Distribution", showlegend = TRUE) %>%
                layout(paper_bgcolor = 'rgba(0,0,0,0)', plot_bgcolor = 'rgba(0,0,0,0)')
            })
          }
        )
      ),
      # Stress impact report plots
      list(
        pattern = "stress_impact_report",
        ui = function(tab_id, tokenUI) {
          fluidRow(
            column(12, class = "col-12 col-md-4 offset-md-4", plotlyOutput(outputId = paste0("plot_pie_", tab_id, "_", tokenUI), height = "550px"))
          )
        },
        plots = list(
          plot_pie = function(df, tab_id, tokenUI) {
            renderPlotly({
              req(df$risk_module, df$external_figures)
              plot_ly(
                df,
                labels = ~risk_module,
                values = ~abs(external_figures),
                type = "pie",
                textinfo = "label+percent",
                hoverinfo = "label+value+percent"
              ) %>%
                layout(title = "External Figures", showlegend = TRUE) %>%
                layout(paper_bgcolor = 'rgba(0,0,0,0)', plot_bgcolor = 'rgba(0,0,0,0)')
            })
          }
        )
      ),
      # Liquidity report plots
      list(
        pattern = "liquidity_report",
        ui = function(tab_id, tokenUI) {
          fluidRow(
            column(12, plotlyOutput(outputId = paste0("plot_liquidity_", tab_id, "_", tokenUI), height = "200px"))
          )
        },
        plots = list(
          plot_liquidity = function(df, tab_id, tokenUI) {
            renderPlotly({
              df_vals <- df %>%
                dplyr::filter(get(names(df)[1]) %in% c("Excess liquidity", "Stress impact", "Available weighted resources")) %>%
                tidyr::pivot_wider(names_from = names(df)[1], values_from = `New methodology`) %>%
                dplyr::mutate(stress = `Stress impact`, excess = `Excess liquidity`)
              
              traces <- list(
                list(
                  type = "bar",
                  x = df_vals$`Stress impact`,
                  y = "Available weighted resources",
                  name = "Stress impact",
                  marker = list(color = 'rgba(255, 99, 71, 0.8)'),
                  text = format(df_vals$`Stress impact`, big.mark = " "),
                  hoverinfo = "text+x"
                ),
                list(
                  type = "bar",
                  x = df_vals$`Excess liquidity`,
                  y = "Available weighted resources",
                  name = "Excess liquidity",
                  marker = list(color = 'rgba(0, 200, 0, 0.7)'),
                  text = format(df_vals$`Excess liquidity`, big.mark = " "),
                  hoverinfo = "text+x"
                )
              )
              
              createGenericMultiTracePlot(
                traces = traces,
                title = "",
                xTitle = "Amount (mEUR)",
                yTitle = "",
                height = 200,
                barmode = "stack",
                orientation = "h"
              )(df, tab_id, tokenUI)
            })
          }
        )
      )
    )
  )
  
  createGenericDashboardUI(id, reactiveReportObject, "rf_liquidity", user, tokenUI, config)
}

#' Create IPLocalMain UI using the generic function
createIPLocalMainUI <- function(id, reactiveReportObject, user = "", tokenUI = "") {
  config <- list(
    appName = "ip_local",
    reportName = "IPLocalMain_Report",
    csvDownloadLabel = "📥 Download all the file in CSV",
    dataFilter = function(data_list) {
      # Ne garder dans data_list que les éléments dont le nom contient "interface"
      data_list[grepl("interface", gsub_underscore_dash(" ", "_", tolower(names(data_list))))]
    },
    tableTypes = function(data_list, table_name, df) {
      # Utiliser RHandsontable pour les tables d'allocation, DT pour les autres
      if (grepl("interface_alloc", gsub_underscore_dash(" ", "_", tolower(table_name)))) {
        "RHandsontable"
      } else {
        "DT"
      }
    },
    totalPatterns = c("intermediate_report", "weighted", "stress_impact"),  # Patterns pour les totaux
    percentageCols = c("lrm_weight", "Impact Weighted Resource"),  # Colonnes de pourcentage
    customControls = list(
      list(
        pattern = "interface_alloc",
        ui = fluidRow(
          column(12, class = "col-12 col-md-4", customSelectWithValues(inputId = "selector_portfolios_alloc", label = "Select a portfolio", icon = "briefcase", message = "Select a portfolio", options = NULL, labels = NULL, multiple = FALSE, disabled = FALSE, selected = NULL)),
          column(12, class = "col-12 col-md-4", customSelectWithValues(inputId = "selector_source_type_alloc", label = "Select a source type", icon = "briefcase", message = "Select a source type", options = NULL, labels = NULL, multiple = FALSE, disabled = FALSE, selected = NULL)),
          column(12, class = "col-12 col-md-4", actionButton(inputId = "action_button_alloc", label = "Generate", class = "btn btn-sm btn-success btn-rounded foundation-btn-primary"))
        ),
        logic = function(df, table_name, tab_id, tokenUI) {
          portefeuilles <- unique(df$portefeuille)
          source_types <- unique(df$source_type)
          
          # Update selectors with actual data
          updateCustomSelectWithValues(session, "selector_portfolios_alloc", options = portefeuilles, labels = portefeuilles)
          updateCustomSelectWithValues(session, "selector_source_type_alloc", options = source_types, labels = source_types)
          
          observeEvent(input$action_button_alloc, {
            req(input$selector_portfolios_alloc, input$selector_source_type_alloc)
            df <- as.data.table(df)
            df_filtered <- df[portefeuille == input$selector_portfolios_alloc & source_type == input$selector_source_type_alloc,]
            df_filtered$portefeuille <- NULL
            df_filtered$source_type <- NULL
            
            value_vars <- setdiff(names(df_filtered), c("portefeuille", "source_type", "year", "SAA Asset Class", "Level 4", "Currency"))
            
            casted_list <- lapply(value_vars, function(vv) {
              dcast(df_filtered, formula = as.formula(paste("`SAA Asset Class` + `Level 4` + Currency ~ year")),
                    value.var = vv, fun.aggregate = function(x) {
                      if (length(x) == 0) NA else if (all(is.na(x))) NA else if (is.numeric(x)) sum(x, na.rm = TRUE) else {
                        x_no_na <- x[!is.na(x)]
                        if (length(x_no_na) == 0) NA else x_no_na[1]
                      }
                    })
            })
            
            names(casted_list) <- value_vars
            
            for (i in seq_along(casted_list)) {
              year_cols <- grep("^[0-9]{4}$", names(casted_list[[i]]), value = TRUE)
              new_names <- paste0(value_vars[i], "_", year_cols)
              setnames(casted_list[[i]], year_cols, new_names)
            }
            
            df_final <- Reduce(function(x, y) merge(x, y, by = c("SAA Asset Class", "Level 4", "Currency"), all = TRUE), casted_list)
            
            output[[paste0("td_dashboard_", tab_id)]] <- renderRHandsontable({
              rhandsontable(df_final, readOnly = FALSE, width = "100%", height = 400) %>%
                hot_cols(columnSorting = TRUE) %>%
                hot_context_menu(allowRowEdit = TRUE, allowColEdit = TRUE)
            })
          })
        }
      )
    )
  )
  
  createGenericDashboardUI(id, reactiveReportObject, "ip_local", user, tokenUI, config)
}

#' Create AMFees UI using the generic function
createAMFeesUI <- function(id, reactiveReportObject, user = "", tokenUI = "") {
  config <- list(
    appName = "am_fees",
    reportName = "AMFees_Report",
    tableTypes = "DT",  # Toutes les tables sont des DataTables
    totalPatterns = c("calcul_report", "kpi_axa_im_report"),  # Patterns spécifiques pour AM Fees
    percentageCols = c("lrm_weight", "Impact Weighted Resource")  # Colonnes de pourcentage
  )
  
  createGenericDashboardUI(id, reactiveReportObject, "am_fees", user, tokenUI, config)
}

#----------------------------------------------------------------------------------#
#------------------------- FONCTION DE LANCEMENT --------------------------------#
#----------------------------------------------------------------------------------#

launch_dashboard_server <- function(appSelected, reactiveReportObject, type = "currentRun") {
  if(gsub_underscore_dash(" ", "_", tolower(appSelected)) %in% c("ip_local")) {
    createIPLocalMainUI(type, reactiveReportObject, user = isolate(user_email()), tokenUI = generate_token(5))
  }
  if(gsub_underscore_dash(" ", "_", tolower(appSelected)) %in% c("rf_liquidity")) {
    createRFLiquidityUI(type, reactiveReportObject, user = isolate(user_email()), tokenUI = generate_token(5))
  }
  if(gsub_underscore_dash(" ", "_", tolower(appSelected)) %in% c("am_fees")) {
    createAMFeesUI(type, reactiveReportObject, user = isolate(user_email()), tokenUI = generate_token(5))
  }
}
